# 5、给Node.js项目增加TS测试

开发三境界

1. console打日志，无敌
2. 通过断点调试，进阶
3. 通过测试驱动开发，高阶

正常开发来说，掌握断点调试已经足够了。比较中肯的评价是够用，但不高级。使用测试驱动开发，关注测试覆盖率，确保在已经测试过的功能前提下开发新功能，这样可以更好的保证软件质量。

使用场景。

1. 关注质量的场景，一般是开源项目，可复用的模块或组件。变动快的项目写测试会比较难受。
2. 使用者必须是极客，不喜欢学习和折腾的同学一般是搞不定的。正常用法对于一般人来说搞定已经不容易了。而测试是遵循开闭原则，准备测试就需要把不常用的方法也写在测试用例，比如正常创建文件，测试用例就需要写删除文件作为模拟。

测试其实也不难，如果大家在掌握基础有余力的情况下，是可以学习一下。

# 增加TS测试

增加js测试和增加ts测试没有本章区别，在测试框架用法上是一样的。唯一增加的就是ts引入类型，所以需要额外做类型测试。

<aside>
💡 自动化测试能够预防无意引入的 bug，并鼓励开发者将应用分解为可测试、可维护的函数、模块、类和组件。

</aside>

## 使用Node.js内置测试框架

Node.js诞生自2009年，在v18之前的13年时间里都没有内置任何测试框架。一直都是使用npm生态。像狼书系列卷三中提到的几个测试框架，都已经有5年以上的历史了。

| 测试**框架** | 当前主要版本 | 年限 |
| --- | --- | --- |
| mocha | v10 | 11 |
| tap | v16 | 11 |
| tape | v5 | 10 |
| ava | v5 | 9 |
| jest | v27 | 7 |

Node.js遵循与JavaScript本身相同的"最小核心"原则。因此，像代码检查工具、代码格式化工具和测试运行器这样的工具最好作为第三方工具提供。虽然这是一个很好的想法很长一段时间，但现在没有标准测试工具的任何语言都显得有些奇怪。Deno、Rust和Go - 它们都有自己内置的测试运行器。

目前各个测试框架和Node.js内置测试框架差异对比如下，参考自[https://glebbahmutov.com/blog/trying-node-test-runner/](https://glebbahmutov.com/blog/trying-node-test-runner/)。

| 特性 | **Mocha** | **Ava** | **Jest** | **Node.js TR** | 推荐 |
| --- | --- | --- | --- | --- | --- |
| 内置在Node中 | 🚫 | 🚫 | 🚫 | ✅ | 🎉 |
| Watch 模式 | ✅ | ✅ | ✅ | ✅ | 🎉 |
| Reporters | lots | via TAP | lots | via TAP |  |
| Assertions | via Chai ✅ | ✅ | ✅ | weak | 😑 |
| Snapshots | 🚫 | ✅ | ✅ | 🚫 |  |
| Hooks | ✅ | ✅ | ✅ | ✅ |  |
| grep support | ✅ | ✅ | ✅ | ✅ |  |
| spy and stub | via Sinon ✅ | via Sinon ✅ | ✅✅ | ✅ |  |
| parallel execution | ✅ | ✅ | ✅ | ✅ |  |
| code coverage | via nyc | via c8 | ✅ | ✅ | 👍 |
| TS support | via ts-node | via ts-node | via ts-jest | via ts-node | 🐢 |

在Node.js v18开始内置了测试框架，在Node.js v20版本中，已经被标记为Stable能力，大家可以放心使用。

```bash
import {test, describe} from 'node:test';
import assert from 'node:assert';

import { HelloWorld } from "./helloworld.mjs";

describe("test suite", function() {
 test("test if works correctly", function() {
   // run some test
   assert.strictEqual(1, 1);
 })
})
```

此时，执行npm test或node —test —watch就可以了。

```bash
$ npm test

> node20@1.0.0 test
> node --watch --test .

▶ test suite
  ✔ test if works correctly (0.104958ms)
▶ test suite (0.894917ms)
```

## 使用Tsd类型测试

写了类型，最好写好类型测试，在ts生态里，可以使用tsd来做类型测试。

创建index.test-d.ts文件

```bash
import { expectType } from "tsd";

import { IPerson } from ".";
import { HelloWorld } from "./src/helloworld";

const cli: IPerson = new HelloWorld();

expectType<Promise<void>>(cli.sayHi("use TypeScript to write Node.js"));
```

执行

```bash
$ npx tsd
```

如果没有任何显示，说明测试通过。如果有错误就会有下面这样的显示。

![Untitled](img/Untitled.png)

再思考一下

- 有代码，就要测试
- 有类型，就要有类型测试

如果想规范的写，就会比较麻烦一点。如果什么都不写，也没啥问题，只是不标准而已。像Rails这种追求极致效率，又想标准的项目，不用ts是正常的。

## 添加TS测试

这样的描述被称作 **规范（specification, spec）**，包含用例的描述以及针对它们的测试，如下所示：

```bash
import { it, describe } from "node:test";
import assert from "node:assert";

import { HelloWorld } from "../src/helloworld";
import { IPerson } from "..";

describe("test suite", function () {
  it("test if works correctly", async function (t) {
    const log = t.mock.method(global.console, "log");

    assert.strictEqual(log.mock.callCount(), 0);
    // call hello world say method
    const cli: IPerson = new HelloWorld();
    await cli.sayHi("liangqi");

    assert.strictEqual(log.mock.callCount(), 1);
  });

  it("test if works incorrectly", async function () {
    const cli: IPerson = new HelloWorld();
    assert.rejects(async () => await cli.sayHi(), new Error("fail"));
  });
});
```

正如你所看到的，一个规范包含三个主要的模块：

1、**`describe("title", function() { ... })`**表示我们正在描述的功能是什么，相当于一个group。用于组织“工人（workers）” —— `it` 代码块。

2、**`it("use case description", function() { ... })**it` 里面的描述部分，我们以一种 **易于理解** 的方式描述特定的用例，第二个参数是用于对其进行测试的函数。表示这是"一系列测试"中的一项，相当于item，如何测试？测试逻辑？都是在it的回调函数中实现的

3、**`assert.equal(value1, value2)**it` 块中的代码，如果实现是正确的，它应该在执行的时候不产生任何错误。
`assert.*` 函数用于检查 测试 函数是否按照预期工作。在这里我们使用了其中之一 —— `assert.equal`，它会对参数进行比较，如果它们不相等则会抛出一个错误。这里它检查了 `pow(2, 3)` 的值是否等于 `8`。还有其他类型的比较和检查，我们将在后面介绍到。

规范可以被执行，它将运行在 `it` 块中指定的测试。我们稍后会看到。

开发流程通常看起来像这样：

1. 编写初始规范，测试最基本的功能。
2. 创建一个最初始的实现。
3. 检查它是否工作，我们运行测试框架（很快会有更多细节）来运行测试。当功能未完成时，将显示错误。我们持续修正直到一切都能工作。
4. 现在我们有一个带有测试的能工作的初步实现。
5. 我们增加更多的用例到规范中，或许目前的程序实现还不支持。无法通过测试。
6. 回到第 3 步，更新程序直到测试不会抛出错误。
7. 重复第 3 步到第 6 步，直到功能完善。

如此来看，开发就是不断地 **迭代**。我们写规范，实现它，确保测试通过，然后写更多的测试，确保它们工作等等。最后，我们有了一个能工作的实现和针对它的测试。

让我们在我们的开发案例中看看这个开发流程吧。

在我们的案例中，第一步已经完成了：我们有一个针对 helloworld 的初始规范。因此让我们来实现它吧。但在此之前，让我们用一些 JavaScript 库来运行测试，就是看看测试是通过了还是失败了。

# 常用测试技巧进阶

## 同步和异步

```tsx

describe("test suite", function () {
  it.only("test if works correctly", async function (t) {

  }
})

test('callback passing test', (t, done) => {
  // done() is the callback function. When the setImmediate() runs, it is'k'i'lnvokes
  // done() with no arguments.
  setImmediate(done);
});
```

## 常用技巧

Exclusive && Inclusive其实很好理解，分别对应only和skip函数。这是只有写的test case比较多的时候才会用的简单技巧。(下面代码时正常写法，但在Node.js v20也是直接运行)

```tsx
import { it, describe } from "node:test";
import assert from "node:assert";

import { HelloWorld } from "../src/helloworld";
import { IPerson } from "..";

describe("test suite", function () {
  it.only("test if works correctly", async function (t) {
    const log = t.mock.method(global.console, "log");

    assert.strictEqual(log.mock.callCount(), 0);
    // call hello world say method
    const cli: IPerson = new HelloWorld();
    await cli.sayHi("liangqi");

    assert.strictEqual(log.mock.callCount(), 1);
  });

  it.skip("test if works incorrectly", async function () {
    const cli: IPerson = new HelloWorld();
    assert.rejects(async () => await cli.sayHi(), new Error("fail"));
  });
});

```

上面的代码只会有一个test complete， 只有only的会被执行，另一个会被忽略掉。每个函数里只能有一个only。如果是it.skip ，那么该case就会被忽略。only和skip共用没有什么实际意义，因为only的作用会把skip屏蔽掉。

实际上，Node.js v20里没有按照常规的写法，而是采用了配置参数结合cli的方式。

skip

```tsx
// The skip option is used, but no message is provided.
test('skip option', { skip: true }, (t) => {
  // This code is never executed.
});

// The skip option is used, and a message is provided.
test('skip option with message', { skip: 'this is skipped' }, (t) => {
  // This code is never executed.
});

test('skip() method', (t) => {
  // Make sure to return here as well if the test contains additional logic.
  t.skip();
});

test('skip() method with message', (t) => {
  // Make sure to return here as well if the test contains additional logic.
  t.skip('this is skipped');
});
```

only

```tsx
// Assume Node.js is run with the --test-only command-line option.
// The 'only' option is set, so this test is run.
test('this test is run', { only: true }, async (t) => {
  // Within this test, all subtests are run by default.
  await t.test('running subtest');

  // The test context can be updated to run subtests with the 'only' option.
  t.runOnly(true);
  await t.test('this subtest is now skipped');
  await t.test('this subtest is run', { only: true });

  // Switch the context back to execute all tests.
  t.runOnly(false);
  await t.test('this subtest is now run');

  // Explicitly do not run these tests.
  await t.test('skipped subtest 3', { only: false });
  await t.test('skipped subtest 4', { skip: true });
});

// The 'only' option is not set, so this test is skipped.
test('this test is not run', () => {
  // This code is not run.
  throw new Error('fail');
});
```

参考API文档[https://nodejs.org/api/test.html#testskipname-options-fn](https://nodejs.org/api/test.html#testskipname-options-fn)

![Untitled](img/Untitled%201.png)

有意思的是它竟然加了**`todo`**这个测试，是一个TODO的简写。

## 生命周期

细心的读者应该发现了我们每次在单元测试开始和结束前都需要做一些准备工作，要么是stub函数，要么是准备mock数据。测试框架提供了四个生命周期钩子，我们可以把一些可以复用的准备工作放到钩子中去：

```tsx
describe('test', function() {
  // 在本测试块的所有测试用例之前执行且仅执行一次
  before(function() {

  });
  // 在本测试块的所有测试用例之后执行且仅执行一次
  after(function() {

  });

  // 在测试块的每个测试用例之前执行（有几个测试用例it，就执行几次）
  beforeEach(function() {

  });
  // 在测试块的每个测试用例之后执行（同上）
  afterEach(function() {

  });

  // 测试用例
  it('test item1', function () {

  })
});
```

在下一章节中，我们在写一个Http Server测试的时候就会用到该知识点，需要在before里先启动服务，然后再去跑测试用例。

## TDD vs BDD

BDD（Behaviour Driven Development）是TDD的一种， 倾向于断言被测对象的行为特征而非输入输出。 [Chai](http://chaijs.com/)的BDD风格断言库包括两部分：`expect`和`should`。=

前面所讲的describe, it, before, after等都属于BDD的范畴，对于TDD，Mocha、Ava等测试库都用suite, test, setup, teardown。

```tsx
suite 'Array', !->
    setup !->
        console.log 'setup'
    teardown !->
        console.log 'teardown'
    suite '#indexOf()', !->
        test 'should return -1 when not present', !->
            assert.equal -1, [1,2,3].indexOf 4
```

TDD是测试驱动开发（Test-Driven Development）的缩写。试驱动开发是一种软件开发方法论，其核心思想是在编写实际代码之前，先编写测试代码。

具体的开发流程如下：

1. 编写测试：首先，开发人员编写一个测试用例，描述了预期的功能和行为。这个测试用例会失败，因为实际的代码尚未编写。
2. 运行测试：运行编写的测试用例，确认测试失败。
3. 编写代码：接下来，开发人员编写足够的代码来满足测试用例的要求。
4. 运行测试：再次运行测试用例，确认测试通过。
5. 重构代码：如果测试通过，开发人员可以对代码进行重构，以提高代码的可读性、可维护性和性能。
6. 重复以上步骤：重复上述步骤，编写下一个测试用例，并按照相同的流程编写代码，直到实现所需的功能。

测试驱动开发的优势在于它强调了测试的重要性，并促使开发人员在编写代码之前就思考和定义代码的行为。这有助于提高代码质量、减少bug，并使代码更易于理解和维护。此外，测试驱动开发还可以提高开发效率，因为通过测试用例可以更早地发现问题，并及时进行修复。

重点回顾：

- 先写测试再开发。
- 依循「红灯／绿灯／重构」循环（Red/Green/Refactor）。
- 优点是在初期就确保测试程序的撰写，而且更容易在初期定义出更贴近使用方的接口。

但 TDD 所撰写出来的测试案例是一连串程式码，过于偏重技术人员，不利与其他非技术的项目参与者讨论，例如 PM (Product Manager) 或 PO (Product Owner)。此外，也不利产生一份如下图这样一目了然、容易阅读的测试报告。

TDD更多的是方法论，指导代码编写方式用的。这块可以讲的内容比较多，建议大家去学习一下敏捷开发，来作为补充。

## Spy & Mock & Stub

在软件测试中，stub、mock 和 spy 是三种用于模拟和测试依赖关系的技术。

- Stub **（插桩）**是一种用于在测试过程中替换外部依赖的技术。它的目的是为了在测试中提供所需的输入，并阻止实际的依赖代码被执行。这样，就可以对代码进行单元测试，而无需考虑外部依赖的影响。
- Mock **（伪造）**是一种用于在测试过程中模拟依赖关系的技术。它的目的是为了测试代码的行为，而不是实际的结果。通常，mock 会跟踪依赖代码的调用次数和参数，并根据预期的行为给出响应。
- Spy（**间谍**） 是一种用于在测试过程中监视依赖关系的技术。它的目的是为了测试依赖代码的实际行为，而不仅仅是它的返回值。通常，spy 会跟踪依赖代码的调用次数和参数，并记录下实际执行的行为。

总的来说，stub 和 mock 的目的都是为了在测试中替换依赖关系，但是 mock 更加强调对代码行为的测试，而 stub 更加强调提供测试所需的输入。相比之下，spy 的目的是为了监视依赖关系的。

在Node.js v20中，stub和spy都可以通过mock来实现。

1、mock示例

```tsx
'use strict';
const assert = require('node:assert');
const { mock, test } = require('node:test');

test('spies on a function', () => {
  const sum = mock.fn((a, b) => {
    return a + b;
  });

  assert.strictEqual(sum.mock.calls.length, 0);
  assert.strictEqual(sum(3, 4), 7);
  assert.strictEqual(sum.mock.calls.length, 1);

  const call = sum.mock.calls[0];
  assert.deepStrictEqual(call.arguments, [3, 4]);
  assert.strictEqual(call.result, 7);
  assert.strictEqual(call.error, undefined);

  // Reset the globally tracked mocks.
  mock.reset();
});
```

2、spy示例

```tsx
import {
  describe,
  it,
  mock
} from 'node:test'
import assert from 'node:assert'

function run({ fn, times }) {
  for (let i = 0; i < times; i++) {
    fn({ current: i * 5 })
  }
}

describe('Spies Test Suite', () => {
  it('should verify calls in a mock', () => {
    const spy = mock.fn()
    run({ fn: spy, times: 2 })

    assert.strictEqual(spy.mock.callCount(), 2)
    const calls = spy.mock.calls
    assert.deepStrictEqual(calls[0].arguments[0], { current: 0 })
    assert.deepStrictEqual(calls[1].arguments[0], { current: 5 })
  })
})
```

3、stub示例

```tsx
import {
  describe,
  it,
  beforeEach,
  mock
} from 'node:test'
import assert from 'node:assert'

class Service {
  static async getTalks({ skip, limit }) {
    const items = await fetch('https://tml-api.herokuapp.com/graphql', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        query: `
        {
          getTalks (skip: ${skip}, limit: ${limit}) {
            totalCount,
            talks {
              _id
              title
            }
          }
        }
        `
      })
    })
    return (await items.json()).data.getTalks.talks
  }
}

function mapResponse(data) {
  return data
    .map(({ _id, title }, index) => `[${index}] id: ${_id}, title: ${title}`)
    .join('\n')
}

async function run({ skip = 0, limit = 10 }) {
  const talks = mapResponse(await Service.getTalks({ skip, limit }))
  return talks
}

describe('Stub Test Suite', () => {
  // only needed if you're not using the context variable
  // in the it() calls
  beforeEach(() => mock.restoreAll())

  it('should stub APIs', async (context) => {
    context.mock.method(
      Service,
      Service.getTalks.name,
    ).mock.mockImplementation(async () => [
      {
        _id: '63865750c839dbaacd8116e1',
        title: 'The Journey About How I Fixed a Bug in the Node.js Core That Affected Thousands of Packages'
      }
    ])

    const result = await run({ limit: 1 })
    const expected = `[0] id: 63865750c839dbaacd8116e1, title: The Journey About How I Fixed a Bug in the Node.js Core That Affected Thousands of Packages`

    assert.deepStrictEqual(Service.getTalks.mock.callCount(), 1)
    const calls = Service.getTalks.mock.calls

    assert.deepStrictEqual(calls[0].arguments[0], { skip: 0, limit: 1 })
    assert.strictEqual(result, expected)
  })
})
```

## Chaijs更好的断言库

Chai是一个JavaScript的断言库，用于编写可读性强的测试代码。它提供了一组易于使用的断言方法，可以帮助开发人员编写清晰、简洁的测试断言。

Chai可以与各种测试框架（如Mocha、Jasmine等）配合使用，使得编写和运行JavaScript测试变得更加容易和高效。

![Untitled](img/Untitled%202.png)

BDD风格有两种风格：expect和should。两者都使用相同的可链接语言来构造断言，但它们在最初构造断言的方式上有所不同。在使用should的情况下将可能会产生一些问题，这也有一些方式去克服这些问题。

**Expect**

 BDD风格暴露expect或should接口。在这两种情况下，你可以用自然语言的形式来链接断言。 Expect也允许你在任何可能发生的断言失败之前添加任意信息。当与布尔值、数字等非描述性主题一起连用时，这将十分好用。

**Should**

Should允许你使用与Expect接口相同的链式断言风格，然而当should风格启动链式断言时将可能在IE浏览器下存在一些问题，因此要注意浏览器兼容性。

除此之外，还有https://github.com/power-assert-js/power-assert 这样的神器，主要是遇到报错，打印错误信息更精准一点，Ava测试框架就是用的它。

## VSCode插件

vscode插件 [https://marketplace.visualstudio.com/items?itemName=connor4312.nodejs-testing](https://marketplace.visualstudio.com/items?itemName=connor4312.nodejs-testing)

![Untitled](img/Untitled%203.png)

# 学会CI/CD

标准开发流程里，在之前，开发测试发布可能是三个人，由于DevOps的流行导致很多时候开发测试发布是一个人，于是衍生出了很多CI/CD平台。

![Untitled](img/Untitled%204.png)

举个例子，以前我们发布npm模块，在本地执行npm publish即可。现在流行的方式是在代码merge到main分分支的时候触发CD，在github actions上直接发布。这在很大程度上更加便利，但也使得学习内容变多了。

下面我们就讲讲CI/CD

## 使用Github Actions

持续集成（Continuous Integration，CI）是一种软件开发实践，通过自动化构建、测试和部署过程，来确保代码的质量和稳定性。CI的目的是尽早发现和解决代码中的问题，以便快速交付高质量的软件。

在CI中，开发者将代码提交到版本控制系统中，然后自动触发构建、测试和部署过程。如果构建或测试失败，开发者会收到通知，以便及时修复问题。这样可以避免在部署时出现问题，并且可以提高开发效率和软件质量。

GitHub Actions（同类产品 CircleCI 、TravisCI）是GitHub提供的一种持续集成和部署工具，可以自动化构建、测试和部署GitHub仓库中的代码。它与GitHub紧密集成，可以通过简单的配置文件来定义工作流程，同时支持多种编程语言和操作系统。

使用GitHub Actions，开发者可以轻松地设置自动化构建和测试流程，以便在代码提交时自动运行。它还支持自定义环境变量、定时触发、通知和部署等功能，可以满足不同项目的需求。

总的来说，持续集成是一种重要的软件开发实践，可以提高软件质量和开发效率。GitHub Actions是一种方便、灵活的CI工具，可以帮助开发者自动化构建、测试和部署GitHub仓库中的代码。

```bash
$ cat .github/workflows/main.yml
name: Node.js CI

on: ["push", "pull_request"]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "20.x"
      - run: npm install
      - run: npm test
      - run: npm run test:coverage
      - name: Upload coverage reports to Codecov
        uses: codecov/codecov-action@v3
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
        with:
          file: ./coverage/lcov.info
```

这里面顶一个2个任务

1、Use Node.js

2、Upload coverage reports to Codecov

查看actions

![Untitled](img/Untitled%205.png)

查看最近一次代码提交触发的ci记录

![Untitled](img/Untitled%206.png)

## 测试覆盖率

使用c8做测试覆盖率生成。

```bash
"scripts": {
	"test:coverage": "c8 tsx --test test/*.ts",
}
```

增加配置.c8rc.json，注意配置中的reporter里的lcov是必须配置的。

```bash
{
  "reporter": [
    "lcov",
    "text",
    "html"
  ]
}
```

执行npm run test:coverage就可以生成对应的测试覆盖率文件了。

测试覆盖率会放在coverage目录下面，打开coverage/index.html文件。

![Untitled](img/Untitled%207.png)

![Untitled](img/Untitled%208.png)

测试覆盖率是保证测试有效的必备手段。

还是以之前的代码举例

```bash
import { IPerson } from "..";

export class HelloWorld implements IPerson {
  async sayHi(name: string): Promise<void> {
    // 调用Promise函数
    const text = await this.helloworld(name);
    console.log(text);
  }

  private helloworld(name?: string): Promise<string> {
    return new Promise(function (resolve, reject) {
      if (name) {
        resolve(`Hello ${name}!`);
      } else {
        reject(new Error("fail"));
      }
    });
  }
}
```

如果只是测试sayHi，代码如下。

```bash
import { test, describe } from "node:test";
import assert from "node:assert";

import { HelloWorld } from "../src/helloworld";
import { IPerson } from "..";

describe("test suite", function () {
  test("test if works correctly", async function (t) {
    const log = t.mock.method(global.console, "log");

    assert.strictEqual(log.mock.callCount(), 0);
    // call hello world say method
    const cli: IPerson = new HelloWorld();
    await cli.sayHi("liangqi");

    assert.strictEqual(log.mock.callCount(), 1);
  });
});
```

此时查看测试覆盖率89.47%

```bash
$ npm run test:coverage

> your-first-nodejs-helloworld-with-ts@1.0.0 test:coverage
> c8 tsx --test test/*.ts

Hello liangqi!
▶ test suite
  ✔ test if works correctly (0.864584ms)
▶ test suite (1.637167ms)

ℹ tests 1
ℹ suites 1
ℹ pass 1
ℹ fail 0
ℹ cancelled 0
ℹ skipped 0
ℹ todo 0
ℹ duration_ms 158.421208
---------------|---------|----------|---------|---------|-------------------
File           | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s
---------------|---------|----------|---------|---------|-------------------
All files      |   89.47 |    83.33 |     100 |   89.47 |
 helloworld.ts |   89.47 |    83.33 |     100 |   89.47 | 15-16
---------------|---------|----------|---------|---------|-------------------
```

此时查看测试报告，具体如下

![Untitled](img/Untitled%209.png)

非常明显是helloworld中的else逻辑没有覆盖。

修改测试代码，增加下面的代码。

```bash
test("test if works incorrectly", async function () {
  const cli: IPerson = new HelloWorld();
  assert.rejects(async () => await cli.sayHi(), new Error("fail"));
});
```

在执行测试覆盖率脚本，此时就100%了。

## Badge

在README.md文件中的badge是一种徽章，通常用于展示项目的一些信息或状态。徽章可以显示项目的构建状态、测试覆盖率、版本号、许可证、支持的平台等等。这些徽章可以帮助读者快速了解项目的一些关键信息，同时也可以增加项目的可信度和吸引力。徽章通常是通过图像或链接的形式呈现在README.md文件中。

例如我们的项目README.md展示如下。

![Untitled](img/Untitled%2010.png)

示例1：测试通过

![Untitled](img/Untitled%2011.png)

```tsx
![build status](https://github.com/npmstudy/your-first-nodejs-helloworld-with-ts/actions/workflows/main.yml/badge.svg)
```

示例1：测试覆盖率

![Untitled](img/Untitled%2012.png)

[https://glebbahmutov.com/blog/trying-node-test-runner/#code-coverage](https://glebbahmutov.com/blog/trying-node-test-runner/#code-coverage)

<aside>
📢 课后练习：自己通过github actions，在每次main分支被合并之后自动发npm包。

</aside>

# 小结

本章节主要讲解测试技巧，ts测试除了比js测试多了类型测试外，其他都是一样的。这里主要Node.js内置的test runner，在不增加模块的前提下就可以搞定，相对来说更简单，对未来Node.js v20这一测试潮流能掌握也是好的。

至于高级测试技巧和CI/CD，能掌握多少掌握多少，毕竟测试是高阶技巧，而spy、mock这些又是高阶中的高级技巧，不必强求必须掌握。

如果能掌握更好，对理解开源项目，自己学习是多有裨益的。