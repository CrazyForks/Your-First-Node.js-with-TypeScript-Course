# 6、Menorepo多模块开发实践

前面5节课里，我们已经把一个Node.js + TS的完整项目开发过程讲完了，虽然主要以Hello world为主，相信对初学者学习来说足够。本章主要讲解nodejs + ts 在多模块开发场景下的用法，以及最佳实践，希望本章能够做到既实用，又能开眼界。

Menorepo是一种软件开发的方法论，它指的是将一个大型项目拆分成多个小型仓库进行管理的做法。每个小型仓库都专注于特定的功能或模块，可以独立开发、测试和部署。通过使用Menorepo，开发团队可以更好地协作、提高开发效率，并且更容易实现代码复用和模块化。

工程领域的解决方案有很多，比如Lerna、yarn workspaces、nx、rush、bolt、pnpm workspace，甚至还有lerna-lite，足见其流行程度之火爆。更有甚至，把前端应用和Node.js应用放到一起，混着packages去用，真是不知道闹多大笑话，不要为了用而用。

我理解Menorepo的典型场景如下。

- 前端应用+组件
- Node.js应+中间件、父子应用
- 组件或中间件+示例

在Node.js世界里，使用后2者用的其实是非常多。

# 开发你的第一个模块

## 初始化

```tsx
$ git clone --depth 1 git@github.com:npmstudy/your-node-v20-menoreopo-project.git my-menorepo
Cloning into 'my-menorepo'...
remote: Enumerating objects: 52, done.
remote: Counting objects: 100% (52/52), done.
remote: Compressing objects: 100% (41/41), done.
remote: Total 52 (delta 2), reused 50 (delta 2), pack-reused 0
Receiving objects: 100% (52/52), 89.56 KiB | 181.00 KiB/s, done.
Resolving deltas: 100% (2/2), done.
```

只克隆最新的代码，无更多git commit记录。

```tsx
$ rm -rf .git/
$ git init
Initialized empty Git repository in /Users/alfred/workspace/npmstudy/my-menorepo/.git/
$ git status
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	.changeset/
	.editorconfig
	.eslintignore
	.eslintrc.json
	.github/
	.gitignore
	.husky/
	.lintstagedrc.json
	.prettierignore
	.prettierrc.json
	.versionrc
	.vscode/
	LICENSE
	README.md
	commitlint.config.js
	docs/
	example/
	nx.json
	package.json
	packages/
	pnpm-lock.yaml
	pnpm-workspace.yaml
	tsconfig.json

nothing added to commit but untracked files present (use "git add" to track)
$ git add .
$ git commit -am 'init'
[main (root-commit) 73acfc8] init
 42 files changed, 7061 insertions(+)
 create mode 100644 .changeset/README.md
 create mode 100644 .changeset/config.json
 create mode 100644 .editorconfig
 create mode 100644 .eslintignore
 create mode 100644 .eslintrc.json
 create mode 100644 .github/workflows/ci.yml
 create mode 100644 .github/workflows/release.yml
 create mode 100644 .gitignore
 create mode 100755 .husky/commit-msg
 create mode 100755 .husky/pre-commit
 create mode 100755 .husky/pre-push
 create mode 100644 .lintstagedrc.json
 create mode 100644 .prettierignore
 create mode 100644 .prettierrc.json
 create mode 100644 .versionrc
 create mode 100644 .vscode/extensions.json
 create mode 100644 LICENSE
 create mode 100644 README.md
 create mode 100644 commitlint.config.js
 create mode 100644 docs/.gitignore
 create mode 100644 example/package.json
 create mode 100644 example/src/app.ts
 create mode 100644 example/tsconfig.json
 create mode 100644 example/tsconfig.node.json
 create mode 100644 example/vite.config.cjs
 create mode 100644 nx.json
 create mode 100644 package.json
 create mode 100644 packages/lib/package.json
 create mode 100644 packages/lib/src/__tests__/index.test.ts
 create mode 100644 packages/lib/src/index.ts
 create mode 100644 packages/lib/tsconfig.json
 create mode 100644 packages/lib/tsup.config.cjs
 create mode 100644 packages/lib/vitest.config.cjs
 create mode 100644 packages/lib2/package.json
 create mode 100644 packages/lib2/src/__tests__/index.test.ts
 create mode 100644 packages/lib2/src/index.ts
 create mode 100644 packages/lib2/tsconfig.json
 create mode 100644 packages/lib2/tsup.config.cjs
 create mode 100644 packages/lib2/vitest.config.cjs
 create mode 100644 pnpm-lock.yaml
 create mode 100644 pnpm-workspace.yaml
 create mode 100644 tsconfig.json
```

然后配置你自己的git仓库即可。

## 安装依赖

pnpm是一种包管理工具，类似于npm和Yarn。它的主要特点是使用硬链接和符号链接来共享依赖项，以减少磁盘空间的占用和安装时间。

pnpm的一些优点包括：

1. 磁盘空间占用更小：由于使用硬链接和符号链接来共享依赖项，pnpm可以显著减少每个项目的磁盘空间占用。这对于Menorepo和多个项目共享相同依赖项的情况特别有用。
2. 安装速度更快：由于共享依赖项，pnpm可以在安装过程中跳过重复的依赖项。这可以显著减少安装时间，特别是在多个项目之间共享相同依赖项的情况下。
3. 更少的网络流量：由于共享依赖项，pnpm只需要下载一次每个依赖项，而不是每个项目都下载一次。这可以减少网络流量的消耗，特别是在多个项目之间共享相同依赖项的情况下。
4. 兼容性：pnpm与npm和Yarn的生态系统兼容，并且可以使用它们的配置文件和命令。这使得迁移到pnpm相对容易，而不需要对项目进行大量的更改。

pnpm是一个快速、高效且节省空间的包管理工具，适用于大型项目和Menorepo。

安装pnpm

```tsx
$ npm i -g pnpm

added 1 package in 4s

1 package is looking for funding
  run `npm fund` for details
```

安装依赖

```tsx
$ pnpm i
Scope: all 3 workspace projects
Lockfile is up to date, resolution step is skipped
Packages: +819
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Progress: resolved 819, reused 819, downloaded 0, added 819, done
node_modules/.pnpm/nx@16.9.1/node_modules/nx: Running postinstall script, done in 988ms

dependencies:
+ @changesets/cli 2.26.2

devDependencies:
+ @commitlint/config-conventional 17.7.0
+ @size-limit/preset-small-lib 8.2.6
+ @types/node 18.17.9
+ @typescript-eslint/eslint-plugin 5.62.0
+ @typescript-eslint/parser 5.62.0
+ commitlint 17.7.1
+ concurrently 8.2.1
+ eslint 8.47.0
+ eslint-config-prettier 8.10.0
+ eslint-import-resolver-typescript 3.6.0
+ eslint-plugin-import 2.28.1
+ eslint-plugin-prettier 4.2.1
+ eslint-plugin-react 7.33.2
+ eslint-plugin-react-hooks 4.6.0
+ husky 8.0.3
+ lint-staged 13.3.0
+ nx 16.9.1
+ prettier 2.8.8
+ size-limit 8.2.6
+ tsup 7.2.0
+ tsx 3.12.10
+ typescript 4.9.5
+ vite 4.4.9
+ vitest 0.32.4

. prepare$ husky install
│ husky - Git hooks installed
└─ Done in 148ms
Done in 5.6s

```

## 目录结构

```tsx
$ tree . -L 4 -I node_modules
.
├── LICENSE
├── README.md
├── commitlint.config.js
├── docs
├── example
│   ├── package.json
│   ├── src
│   │   └── app.ts
│   ├── tsconfig.json
│   ├── tsconfig.node.json
│   └── vite.config.cjs
├── nx.json
├── package-lock.json
├── package.json
├── packages
│   ├── lib
│   │   ├── package.json
│   │   ├── src
│   │   │   ├── __tests__
│   │   │   └── index.ts
│   │   ├── tsconfig.json
│   │   ├── tsup.config.cjs
│   │   └── vitest.config.cjs
│   └── lib2
│       ├── package.json
│       ├── src
│       │   ├── __tests__
│       │   └── index.ts
│       ├── tsconfig.json
│       ├── tsup.config.cjs
│       └── vitest.config.cjs
├── pnpm-lock.yaml
├── pnpm-workspace.yaml
└── tsconfig.json

10 directories, 24 files
```

该项目包含3个子项目，具体如下。

1. packages 是pnpm-workspace.yaml中配置的目录
    1. lib是示例模块
    2. lib2是示例模块
2. example是示例目录

## 模块代码

目录结构

```tsx
$ tree packages/lib/ -I node_modules
packages/lib/
├── package.json
├── src
│   ├── __tests__
│   │   └── index.test.ts
│   └── index.ts
├── tsconfig.json
├── tsup.config.cjs
└── vitest.config.cjs

2 directories, 6 files
```

具体代码

![Untitled](img/Untitled.png)

要点说明。

1. 采用了Vitest作为测试框架，这是因为它不依赖Node.js版本
2. 在package.json里没有配置type=module，而是支持cjs和esm二种格式。
3. 采用tsup进行构建
    1. build：生成dts
    2. build:fast：不生成dts

这是对大家比较陌生的可能是Vitest。

Vitest是一个基于Vite的单元测试框架，它具有以下优点：

1. 快速：Vitest被设计为高效的单元测试框架，能够快速执行测试用例。它利用Vite的快速构建能力和热重载功能，提供了快速的测试反馈。
2. 简单易用：Vitest提供了简洁的API和清晰的文档，使得编写和运行测试用例变得简单易懂。它与Vite的生态系统紧密集成，可以无缝地与现有的Vite项目集成。
3. 强大的功能：Vitest支持常见的单元测试功能，包括断言、测试套件、测试组织和测试覆盖率等。它还提供了丰富的扩展性，可以根据项目的需求进行自定义配置和扩展。
4. 社区支持：Vitest是一个开源项目，拥有活跃的社区支持。你可以在GitHub上找到其代码库，并参与讨论、提问问题或贡献代码。

它个快速、简单易用且功能强大的单元测试框架，适用于使用Vite构建的项目。它和Node.js test runner很像，你可以通过阅读文档和示例来了解更多关于Vitest的信息，并开始在你的项目中使用它。

<aside>
💡 学会一门，其他就会触类旁通，这是学习的好处。

</aside>

## 示例

目录

```tsx
$ tree example/ -I node_modules
example/
├── package.json
├── src
│   └── app.ts
└── tsconfig.json

1 directory, 3 files
```

这里以koa为例

```tsx
import Koa from 'koa';
import { lib } from 'lib2';
const app = new Koa();

app.use(async (ctx) => {
  ctx.body = `Hello ${lib()}`;
});

app.listen(3000);
```

执行

```tsx
$ pnpm example

> your-node-v20-menoreopo-project@ example /Users/alfred/workspace/npmstudy/my-menorepo
> npm run build && pnpm -F example dev

> build
> nx run-many -t build

    ✔  nx run lib2:build  [existing outputs match the cache, left as is]
    ✔  nx run lib:build  [existing outputs match the cache, left as is]

 ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

 >  NX   Successfully ran target build for 2 projects (26ms)

   Nx read the output from the cache instead of running the command for 2 out of 2 tasks.

> example@1.0.0 dev /Users/alfred/workspace/npmstudy/my-menorepo/example
> tsx watch src/app.ts
```

要点：

- 先构建lib和lib2
- 然后tsx watch src/app.ts

此时访问[http://127.0.0.1:3000/](http://127.0.0.1:3000/)

![Untitled](img/Untitled%201.png)

其实，在这种Node.js Server应用里，也是可以进行测试的，比如使用supertest测试api和页面，甚至如果想极致一点，也可以使用Cypress做e2e测试。

这是从简，并没有加，如果大家感兴趣，可以作为课后练习。

## 新增模块

如果想新增一个模块，那就通过简单的shell命令就可以了。

```tsx
$ cp -rf packages/lib packages/lib3
```

查看packages下内容，会发现多了lib3

```tsx
$ tree packages/ -L 2
packages/
├── lib
│   ├── dist
│   ├── node_modules
│   ├── package.json
│   ├── src
│   ├── tsconfig.json
│   ├── tsup.config.cjs
│   └── vitest.config.cjs
├── lib2
│   ├── dist
│   ├── node_modules
│   ├── package.json
│   ├── src
│   ├── tsconfig.json
│   ├── tsup.config.cjs
│   └── vitest.config.cjs
└── lib3
    ├── dist
    ├── node_modules
    ├── package.json
    ├── src
    ├── tsconfig.json
    ├── tsup.config.cjs
    └── vitest.config.cjs

12 directories, 12 files
```

这样其实已经很简单了。如果大家想做更多工程化内容，可以自己写一个脚手架。

技术栈推荐。

1. cli解析，推荐使用commander或cac
2. 输入项，推荐使用 [https://www.npmjs.com/package/inquirer](https://www.npmjs.com/package/inquirer)
3. 模版引擎推荐使用handlebars
4. 可以[**download-git-repo](https://www.npmjs.com/package/download-git-repo) 或** [https://www.npmjs.com/package/dclone](dclone).

<aside>
💡 在前端开发中，脚手架是一个用于快速搭建项目结构和提供初始配置的工具。它可以帮助开发者快速创建项目，并集成了一些常用的工具、库和最佳实践。

</aside>

# 行业真知

在 https://github.com/npmstudy/your-node-v20-menoreopo-project 里，我们用到的技术栈如下。

```markdown
- [Tsup](https://tsup.egoist.dev/) as a TypeScript universal package.
- [Tsx](https://github.com/esbuild-kit/tsx) as a Node.js enhanced with esbuild to run TypeScript & ESM
- [Tsd](https://github.com/SamVerschueren/tsd) as type test runner
- [Tsdoc](https://tsdoc.org/) as document
- [PNPM](https://pnpm.io/workspaces) as workspace manager and package manager.
- [Vitest](https://vitest.dev/) as a test runner.
- [Size Limit](https://github.com/ai/size-limit) as a size limit plugin.
- [Prettier](https://prettier.io/) as a code formatter.
- [ESLint](https://eslint.org/) as a code linter.
- [NX](https://nx.dev) as cacheable operations.
- [Changesets](https://github.com/changesets/changesets/) as a way to manage changes and releases.
- [c8](https://www.npmjs.com/package/c8) as coverage
- [supertest](https://www.npmjs.com/package/supertest) as server test
- [cypress](https://www.cypress.io/) as e2e test
```

运行TS的4个（已讲过）

1. tsup
2. tsx
3. tsd
4. tsdoc

模块安装和menorepo

1. pnpm

测试

1. Vitest
2. c8（已讲过）
3. supertest
4. cypress

其他

1. Size-limit
2. NX
3. ESLint
4. Prettier
5. Changesets

其中ESLint和Prettier前端同学都熟悉，这里就细讲了。

- ESLint是一个用于JavaScript和JSX代码的静态代码分析工具。它可以帮助开发者在编写代码的过程中发现并修复潜在的问题，以确保代码的质量和一致性。
- Prettier是一个代码格式化工具，用于自动格式化代码以保持一致的代码风格。它支持多种编程语言，包括JavaScript、CSS、HTML、JSON等。Prettier可以帮助开发者快速、准确地格式化代码，提高代码的可读性和可维护性。它可以与其他代码检查工具（如ESLint）配合使用，以确保代码的质量和一致性。

它俩是VSCode非常常见的搭档。

## Pnpm

包管理演进历史，参考[https://zhuanlan.zhihu.com/p/582229306](https://zhuanlan.zhihu.com/p/582229306)，各个包管理器对比如下。

pnpm在2018年发布，作为npm的更快速和更高效的替代品。

![Untitled](img/Untitled%202.png)

选择pnpm的原因，第一个就是安装速度快，参考官方的[https://pnpm.io/benchmarks](https://pnpm.io/benchmarks)基准测试数据。

| 行为 | 缓存 | lockfile | node_modules | npm | **pnpm** | Yarn | Yarn PnP |
| --- | --- | --- | --- | --- | --- | --- | --- |
| install |  |  |  | 34.3s | 13.2s | 22.1s | 20.2s |
| install | ✔ | ✔ | ✔ | 2.5s | 1.6s | 695ms | n/a |
| install | ✔ | ✔ |  | 9.5s | 4.8s | 8.8s | 668ms |
| install | ✔ |  |  | 15.5s | 9.3s | 22.8s | 15.2s |
| install |  | ✔ |  | 19.3s | 9.8s | 8.9s | 670ms |
| install | ✔ |  | ✔ | 2.8s | 3.4s | 16s | n/a |
| install |  | ✔ | ✔ | 2.5s | 1.7s | 681ms | n/a |
| install |  |  | ✔ | 2.8s | 8.8s | 16.6s | n/a |
| update | n/a | n/a | n/a | 9.2s | 5.8s | 8.7s | 16.9s |

还有一些其他特性

![Untitled](img/Untitled%203.png)

pnpm使用的是npm version 2.x类似的树形结构，同时使用.pnpm 以平铺的形式储存着所有的包。这里的.pnmp为虚拟存储目录，该目录通过`<package-name>@<version>`来实现相同模块不同版本之间隔离和复用，由于它只会根据项目中的依赖生成，并不存在提升，所以它不会存在之前提到的**Phantom dependencies**问题！

然后使用Store + Links和文件资源进行关联。简单说pnpm把会包下载到一个公共目录，如果某个依赖在 sotre 目录中存在了话，那么就会直接从 store 目录里面去 hard-link，避免了二次安装带来的时间消耗，如果依赖在 store 目录里面不存在的话，就会去下载一次。

通过Store + hard link的方式，不仅解决了项目中的NPM doppelgangers问题，项目之间也不存在该问题，从而完美解决了npm3+和yarn中的包重复问题！

![Untitled](img/Untitled%204.png)

pnpm除了安装速度快，节省磁盘空间，避免幽灵依赖等优化，也内置了对monorepo的支持。使用起来比较简单，在项目根目录中新建pnpm-workspace.yaml文件，并声明对应的工作区就好。

```tsx
$ cat pnpm-workspace.yaml
packages:
  - 'example'
  - 'packages/*'

```

剩下的就是运行时处理。之前nx run-many解决了menorepo子模块运行的问题。很多时候我们需要在根目录执行某个项目 的构建脚本，需要通过—filter或-F过滤之后，再执行，示例如下。

```tsx
$ pnpm -F example dev
```

以上都是pnpm的有点，其实pnpm的演进还是比较快的，比如pnpm v7和pnpm v8版本差异还是比较大的，且不完全兼容。但整个社区是比较活跃的，

<aside>
💡 都说Node.js和前端复杂，其实是背后工程复杂度导致的，如果没有这么多依赖，这么多版本，也不会出现幻影依赖这样的问题。其实，对用的人来说无感的，我就用pnpm v8，像其他社区一样，也没问题的。真正的问题是Node.js和前端变化太快，你在较短时间内，总可能会遇到pnpm v7的代码，甚至互相切换。

</aside>

## Vitest

- **A Vite-native unit test framework.**

    **It's fast!**


优点：

1. 基于vite机制，性能极佳，比jest快很多，
2. 对esm支持极好
3. 兼容jest api
4. 很多技术选型也都是非常棒，比如tinypool，都是很经典的。

如果我们想要从请求开始来测试node服务接口返回的数据是否正常，也就是说进行一个整体性测试，那么 superTest 就是一个非常好的选择。superTest可以帮助我们去请求本地 koa 或者 express这类web框架所编写的路由接口，而且对接口返回的状态码、数据等进行断言校验。

它本身不依赖任何测试框架，所以我们可以直接把它丢到mocha的测试用例中执行：

先写一个简单的Koa的Hello world。见app.js

```tsx
import Koa from "koa";
const app = new Koa();

// response
app.use((ctx) => {
  ctx.body = "Hello Koa";
});

export default app;
```

再写一个测试脚本，run.js

```tsx
import app from "./index.js";

app.listen(3000);
```

此时，执行node run.js就可以启动服务了。然后我们看一下测试如何编写。

```tsx
import { expect, test } from "vitest";
import supertest from "supertest";
import app from "./index.js";

test("koa app", async () => {
  const res = await supertest(app.callback()).get("/");

  expect(res.type).toEqual("text/plain");
  expect(res.status).toEqual(200);
  expect(res.text).toEqual("Hello Koa");
});
```

这个代码和我们在Node.js v20的test runner里几乎是一模一样的。通过下面命令即可运行测试。

```tsx
$ npx vitest run

 RUN  v0.34.6 /Users/alfred/workspace/npmstudy/vitest-with-supertest

 ✓ index.test.js (1)
   ✓ koa app

 Test Files  1 passed (1)
      Tests  1 passed (1)
   Start at  11:56:53
   Duration  232ms (transform 17ms, setup 0ms, collect 69ms, tests 8ms, environment 0ms, prepare 44ms)
```

说明。

- vitest不带run参数，是watch运行模式，和jest类似
- vitest带run参数，是单次运行模式

## Cypress

安装

```tsx
$ npm install cypress --save-dev --registry=https://registry.npmmirror.com
```

通过npx cypress open打开。

```tsx
$ npx cypress open
It looks like this is your first time using Cypress: 13.3.0

✔  Verified Cypress! /Users/alfred/Library/Caches/Cypress/13.3.0/Cypress.app

Opening Cypress...

DevTools listening on ws://127.0.0.1:54097/devtools/browser/dc560ea2-0aad-47a4-9461-1e160b19a5a3
```

![Untitled](img/Untitled%205.png)

![Untitled](img/Untitled%206.png)

![Untitled](img/Untitled%207.png)

![Untitled](img/Untitled%208.png)

修改代码，手动执行node run.js启动服务。

```tsx
describe("template spec", () => {
  it("passes", () => {
    cy.visit("http://127.0.0.1:3000");
    cy.contains("Hello Koa");
  });
});
```

![Untitled](img/Untitled%209.png)

为了简化操作，我们把启动服务放到cypress.config.js里。

```tsx
import { defineConfig } from "cypress";
import app from "./index.js";
export default defineConfig({
  e2e: {
    setupNodeEvents(on, config) {
      // implement node event listeners here
      on("before:run", async (details) => {
        /* ... */
        await app.listen(3000);
      });
    },
  },
});
```

此时，执行结果如下。

```tsx
$ npx cypress run

DevTools listening on ws://127.0.0.1:61755/devtools/browser/0a2f2716-10cb-49b9-a2c9-5163469574e9

====================================================================================================

  (Run Starting)

  ┌────────────────────────────────────────────────────────────────────────────────────────────────┐
  │ Cypress:        13.3.0                                                                         │
  │ Browser:        Electron 114 (headless)                                                        │
  │ Node Version:   v20.6.1 (/Users/alfred/.nvm/versions/node/v20.6.1/bin/node)                    │
  │ Specs:          1 found (spec.cy.js)                                                           │
  │ Searched:       cypress/e2e/**/*.cy.{js,jsx,ts,tsx}                                            │
  └────────────────────────────────────────────────────────────────────────────────────────────────┘

────────────────────────────────────────────────────────────────────────────────────────────────────

  Running:  spec.cy.js                                                                      (1 of 1)

  template spec
    ✓ passes (27ms)

  1 passing (47ms)

  (Results)

  ┌────────────────────────────────────────────────────────────────────────────────────────────────┐
  │ Tests:        1                                                                                │
  │ Passing:      1                                                                                │
  │ Failing:      0                                                                                │
  │ Pending:      0                                                                                │
  │ Skipped:      0                                                                                │
  │ Screenshots:  0                                                                                │
  │ Video:        false                                                                            │
  │ Duration:     0 seconds                                                                        │
  │ Spec Ran:     spec.cy.js                                                                       │
  └────────────────────────────────────────────────────────────────────────────────────────────────┘

====================================================================================================

  (Run Finished)

       Spec                                              Tests  Passing  Failing  Pending  Skipped
  ┌────────────────────────────────────────────────────────────────────────────────────────────────┐
  │ ✔  spec.cy.js                                42ms        1        1        -        -        - │
  └────────────────────────────────────────────────────────────────────────────────────────────────┘
    ✔  All specs passed!                         42ms        1        1        -        -        -
```

Cypress写e2e测试还是非常简单的，它也支持测试覆盖率，也可以生产reporter，和我们在上一章节学到的c8类似，大家如果感兴趣也可以自己实现一下。

除此之外，Cypress还支持组件级别测试，可以说又是填补了一块空白，意义非凡，对于开发组件库来说，也是必不可少的功能。

## Size-limit

size-limit 是一个防止 JavaScript 库膨胀的工具，用于控制文件包的大小。如果不小心添加了大量的依赖关系，size-limit 会引发错误。

limit-size 是一个用于控制文件包大小的工具，它可以读取文件的大小，并与设置的文件大小进行比较。

![Untitled](img/Untitled%2010.png)

使用GitHub操作Size Limit将在拉取请求讨论中作为评论发布捆绑大小更改。

![Untitled](img/Untitled%2011.png)

也可以结合https://github.com/statoscope/statoscope 进行分析。

 [Statoscope: A Course Of Intensive Therapy For Your Bundle](https://www.smashingmagazine.com/2022/02/statoscope-course-intensive-therapy-bundle/).

![Untitled](img/Untitled%2012.png)

## Nx

<aside>
💡 Nrwl(开源构建系统NX背后的公司)已经接管了Lerna。NX是一个由前谷歌员工开发的构建系统，它利用了谷歌内部工具使用的许多技术。Lerna v5是这种新管理方式下的第一个版本，它更新了过时的包，并开始对存储库本身进行一些清理。从V5.1+开始，Lerna提供了集成NX的新可能性，并将许多任务调度工作推迟到NX。

</aside>

在使用Menorepo时，你一定听说过 Nx。简而言之，Nx 可以加快和简化与Menorepo的工作，并提供有用的实用程序。

官方介绍：

> Nx是一个智能、快速和可扩展的构建系统，具有一流的Monorepo支持和强大的集成。
>

Nx的目标是：

- 加快你的前端项目工程化
- 提供一流的开发体验

大部分情况需要了解的就是下面6个指点就够了。

- nx run-many
- dependency graph + nx affected
- nx-enforce-module-boundaries es-linting
- computation cache
- nx cloud
- buildable libs

nx会自动引入上一次build的cache缓存，从而加快编译速度.在[How Caching Works](https://nx.dev/concepts/how-caching-works)这篇文章中非常详细地说明了 nx 缓存构建结果的机制：

nx 会计算当前执行的 target 的 Hash 作为 cache key，在 target 执行完成后把构建输出（包括终端输出、构建结果文件）作为缓存内容存储起来。

![Untitled](img/Untitled%2013.png)

最常用的动作

- 将所有的子项目统一打包编译，命令:`npx nx run-many --target=build`
- 如果不需要使用cache缓存，可以使用命令:`npx nx run-many --target=build --skip-nx-cache`
- 如果需要查看当前子项目依赖的项目是否被修改，可以使用命令：`npx nx affected --target=buil`d
- 如果需要查看当前子项目依赖的图，可以使用命令：`npx nx graph`

比如依赖如下。

```tsx
$ pnpm project-graph

> your-node-v20-menoreopo-project@ project-graph /Users/alfred/workspace/npmstudy/your-node-v20-menoreopo-project
> nx graph

 >  NX   Project graph started at http://127.0.0.1:4211/projects
```

![Untitled](img/Untitled%2014.png)

nx除了本地换成，其实还支持云服务（remote cache）。即nx.app，如果真的对ci/cd有极强的需求，其实也是可以考虑选择的。

![Untitled](img/Untitled%2015.png)

在https://github.com/npmstudy/your-node-v20-menoreopo-project 项目里，我们其实只用了非常简单的npm nx run-many

```tsx
  	"build": "nx run-many -t build",
    "build:fast": "nx run-many -t build:fast",
    "dev": "nx run-many -t dev",
    "test": "nx run-many -t test",
```

虽然多了一个nx模块，但执行的时候能够利用本地缓存，加快打包、测试速度，已经是非常好的事儿。

## Changesets

Changesets 是一个用于 Monorepo 项目下版本以及 Changelog 文件管理的工具。目前一些比较火的 Monorepo 仓库都在使用该工具进行项目的发包例如 pnpm、mobx 等。

changesets 主要关心 monorepo 项目下子项目版本的更新、changelog 文件生成、包的发布。一个 changeset 是个包含了在某个分支或者 commit 上改动信息的 md 文件，它会包含这样一些信息:

- 需要发布的包
- 包版本的更新层级(遵循 semver 规范)
- CHANGELOG 信息

在 changesets 工作流会将开发者分为两类人，一类是项目的维护者，还有一类为项目的开发者，两者的职责可以通过如下流程图很简洁的表示出来:

![Untitled](img/Untitled%2016.png)

根据上图， changesets 的工作流程是这样：开发者在 Monorepo 项目下进行开发，开发完成后，给对应的子项目添加一个 changesets 文件。项目的维护者后面会通过 changesets 来消耗掉这些文件并自动修改掉对应包的版本以及生成 CHANGELOG 文件，最后将对应的包发布出去。

常用的命令只有add、version、publish

![Untitled](img/Untitled%2017.png)

# 如何学习

## 开源

《*大教堂与集市*》是开源运动的《圣经》，颠覆了传统的软件开发思路，影响了整个软件开发领域。

![Untitled](img/Untitled%2018.png)

我所总结的4t（tsx、tsup、tsdoc、tsd），其实都是我在各种开源项目里学的，我会养成一个习惯，看到一个好的项目，首先看package.json，除了依赖包，还有构建相关，都是技巧。

开源是我学习的最好的途径。如果不懂，还可以去提issue，再后面就可以自己创造一些更有趣项目。

我之所以了解tsd，是因为阅读fastify源码，翻它的package.json：[https://github.com/fastify/fastify/blob/main/package.json#L184](https://github.com/fastify/fastify/blob/main/package.json#L184)。

其实还有更加轻量级的https://github.com/mrazauskas/tsd-lite，我是在翻jest中expect模块的时候找见的，地址[https://github.com/jestjs/jest/blob/main/packages/expect/package.json](https://github.com/jestjs/jest/blob/main/packages/expect/package.json)。

另外，《开放式协作:开源软件的生产与维护》也是不错的，值得一读。

## 刻意练习

我认同这本书的观点

<aside>
💡 刻意练习是一种有目的的练习：①定义明确的特定目标，积跬步以致千里；②保持专注，把全部注意力集中于你的任务上；③需要反馈，反馈会帮你搞清楚哪方面不足，离目标有多远；④走出舒适区，不走出舒适区永远无法进步。

</aside>

![Untitled](img/Untitled%2019.png)

《迷茫时学习 Node.js 最好的方法》这篇文章提到的观点大家可以试试。

> 今天小弟过来找我，说迷茫，我告诉他一个密法：一天看 10 个 npm 模块，坚持一年就是 3000+，按正常工作需要，超过 200 个都很厉害了。
>

启发

1. 源码学习多了，应用起来信手拈来。
2. 阅读文档中，大佬的经验给人启发。
3. 最难的不是下决心，而是坚持，这是最值得自豪的。

参考这篇文章[https://mp.weixin.qq.com/s/Jfmu1Z8G3plgUgP8XdcqqQ](https://mp.weixin.qq.com/s/Jfmu1Z8G3plgUgP8XdcqqQ)。

## 挠自己的痒

rework是一本经典的书，我最喜欢的观点就是挠自己的痒，自己需要什么，就动手写什么。如果自己都不需要，别人真的会需要吗？不一定的。

尤其是对初学者来说，从自己感兴趣的地方开始，是最好的选择。

![Untitled](img/Untitled%2020.png)

vitest作者antfu，就是一个疯子，vitest早期我就关注了，每天提交代码量极其大，感觉为了这个项目可以不眠不休，精神可嘉。他的一篇关于自己与开源的故事，以剪羊毛自喻，a)发现问题b)解决问题c)点到为止d)挠自己的痒，也是非常不错的，推荐阅读[https://antfu.me/posts/about-yak-shaving-zh](https://antfu.me/posts/about-yak-shaving-zh)。

# 小结

作为一门入门课程，我希望它的定位如下。

1. 以ts和node v20入门，让大家有一个基本概念。
2. 通过第一个ts编写的node项目，讲解了开发过程中从开发、调试、测试、发布四个方面进行讲解，其中调试和测试是开发过程中最常用的功能，所以单独章节进行讲解。
3. 讲解nodejs + ts 在多模块开发场景下的用法，以及最佳实践。

希望本课程能够做到既实用，又能开眼界。

课后练习，有助教帮忙Review

1. 自己通过Github Action编写CD示例
2. 自己参考当前项目，写Cli脚手架
3. 补充supertest测试
4. 补充cypress测试

需要深入学习的内容。关注npmstudy账号，会持续更新教程。

1. Node.js v20系统学习
2. TS各种要点学习和实现，最好结合Web框架实现
3. 学习pnpm、changeset、vitest等模块开发技巧
4. AI时代Node全栈应用开发