# 2、Hello TypeScript

TypeScript 是一种由微软开发的自由和开源的编程语言，它是 JavaScript 的一个超集，可以编译成纯 JavaScript。TypeScript 在 JavaScript 的基础上添加了可选的**静态类型**和**基于类的面向对象编程，**结合了类型检查和静态分析，显式接口，以及类型对编辑器的增强收益，使得TypeScript在JavaScript开发者中使用占比非常高，大有替换之势。

在ts里加入类型，在编译成js的时候擦除类型。在[Playground](https://www.typescriptlang.org/play?#code/DYUwLgBArgziBOA5AhgWxALhmeBLAdgOYQC8EA5ABYjDAD25QA)里测试，如下图。

![Untitled](img/Untitled.png)

它有如下6个特性。

![Untitled](img/Untitled%201.png)

1、跨平台：TypeScript编译器可以安装在任何操作系统上，如Windows、MacOS和Linux。

2、面向对象语言：TypeScript提供了类、接口和模块等功能。因此，可以为客户端和服务器端开发编写面向对象的代码。

3、静态类型检查：TypeScript使用静态类型，并在编译时帮助进行类型检查。因此，您可以在编写代码时找到错误，而无需运行脚本。

4、可选的静态类型：如果您使用JavaScript的动态类型，则TypeScript还允许可选的静态类型。

5、IDE支持：无论VSCode还是WebStorm等都有更好的支持。

6、ES6新特性支持：TypeScript包含了计划中的ECMAScript 2015（ES 6、7）的大部分功能，如类、接口、箭头函数等。

其实，TypeScript真正厉害的是他的背景，出身名门，同辈父辈都是狠人。

![Untitled](img/Untitled%202.png)

1、背后金主是微软，它就是地主家的小儿子。

2、亲爹是安德斯·海尔斯伯格（Anders Hejlsberg），1960年12月出生于丹麦哥本哈根，曾在丹麦科技大学学习工程学，计算机科学家。 Turbo Pascal编译器的主要作者，Delphi、C#和TypeScript之父。他是创造Borland传奇的男人。

3、它的哥哥是VSCode，干翻Atom，[在2021年开发人员占比就超过了50%](https://www.zdnet.com/article/visual-studio-code-how-microsofts-any-os-any-programming-language-any-software-plan-is-paying-off/)，（总人数2400万，有1400万安装了），其他语言工程师我不清楚，至少前端Node绝大部分都是VSCode或者VSCode+WebStorm双修。

4、他大爷（哥哥的爸爸）是Erich Gamma，《设计模式：可复用面向对象软件基础》的四人帮之一。

# 为什么要用TypeScript？

正常来讲，只会ESM写法也是足够开发Node.js用的，掌握了TypeScript可以更好的应对大规模应用开发，多花一点时间，对可维护性更好。

- 良好的类型支持是现代框架必须的功能
- 可维护性大大提升，为迭代打下坚实基础
- 适用于大规模开发

![Untitled](img/Untitled%203.png)

## 黑粉

![Untitled](img/Untitled%204.png)

Ruby on Rails作者DHH在2023年宣布在Turbo 8中放弃使用TypeScript，笔者以为Rails本身追求的是开发效率，十五分钟写一个Blog，结果加了TypeScript，五分钟还没写完类型定义。敏捷社区喜欢测试驱动开发（TDD），本来只需要改改代码就行，现在还要管类型定义和类型 测试，很显然，这样做的效率和质量是矛盾的，在收益不够高的时候，放弃也是正常。型和测试都是一个[上下文](https://link.zhihu.com/?target=https%3A//www.jdon.com/tag-15977/)的上文，也就是一个上下文的预设，如果预设类型错误了，全盘皆输，无类型的Javascript则在探索不确定问题上效率更高。

1、Rails是崇尚效率的框架，截图中5分钟那个有误，早在2005年[dhh](https://www.zhihu.com/search?q=dhh&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3222336155%7D)成名之作，就是15分钟写一个Blog。所以加了ts，会阻碍效率，对于这样一个追求极致效率的团队，弃用是正常的。

2、TS适合的是大型项目，团队水平要么很高，要么很低，其实效果都是非常好的。而Rails其实不是很大型的项目，我没太见过，大家都是想快速交付。

3、Ruby社区有[敏捷基因](https://www.zhihu.com/search?q=%E6%95%8F%E6%8D%B7%E5%9F%BA%E5%9B%A0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3222336155%7D)，喜欢TDD或XP，代码变动极快的情况下，要把测试改完，要关注类型测试，就会多出非常多的工作。

4、Rails程序员也都是以Ruby为主，js为辅。当js能完成，非要用ts搞，会带来很多负担，对他们而言roi不高。前端之所以喜欢ts，前端会js为主，以ts为辅就很简单。

某些场景确实不需要TS，纯ES已经比js好很多了，这种纯用ES/JS的比例是比较少的。

## 奉若神教

主要人群：大厂前端、开源贡献者。

TS适合的是大型项目，团队水平要么很高，要么很低。

![Untitled](img/Untitled%205.png)

高p会想，下面的一线同学少犯点低级错误，参考现在这故障分，搞得人心惶惶，如果只是麻烦一下一线开发，对稳定性有好处，问题不大。一线同学，大家都觉得ts挺先进，别管会不会，用上再说，不行还有any大法。通常大厂都是会比较愿意用ts的。

- 规范，比黑魔法要重要，这其实也是选React的原因
- 低级错误少，人水平如果高，其实也无所谓的，就怕参差不齐
- 不差那点时间，dddd
- 不出故障啥都好，稳定性压到一切。
- 传承会好的多，喜欢研究带着飞。

## 中立

![Untitled](img/Untitled%206.png)

不吹不黑。

<aside>
💡 仔细想了一下，我应该是中立派。从Commonjs时代过来，我习惯js，在大厂多年，也习惯了ts各种奇技淫巧。我的观点是写库要严格用ts，写应用，可以放宽，协作人越多，越应该少用Hack。

</aside>

我的观点：对于TS，你一定要学，但在不在项目使用依照团队和项目类型而定。

## 举例看一下ts成本

以tomcat为例。

```jsx
import debug from 'debug';
import Koa from 'koa';

import { Plugable } from './plugin';
import { mergeDeep } from './utils';

const log = debug('@tomrpc/core/fn');

const ProxyDefaultConfig = {
  proxy: {
    inject: 'before', //init | load | before | after
    before: [],
  },
};

export interface IProxyConfig {
  name?: string | 'tomapp';
  proxy?: {
    inject: 'init' | 'load' | 'before' | 'after';
    before: [];
  };
}

export class Proxy extends Plugable {
  public inject;

  constructor(cfg?: IProxyConfig) {
    super(mergeDeep(ProxyDefaultConfig, cfg));
  }

  proxy() {
    return async (ctx: Koa.BaseContext, next) => {
      log('proxy default');
      await next();
      log('proxy default end');
    };
  }
}
```

最初的版本，我基本上只加了必要的类型。比如配置项这种。

以hono为例。

```jsx
import { HonoBase } from './hono-base'
import type { HonoOptions } from './hono-base'
import { RegExpRouter } from './router/reg-exp-router'
import { SmartRouter } from './router/smart-router'
import { TrieRouter } from './router/trie-router'
import type { Env, Schema } from './types'

export class Hono<
  E extends Env = Env,
  S extends Schema = {},
  BasePath extends string = '/'
> extends HonoBase<E, S, BasePath> {
  constructor(options: HonoOptions<E> = {}) {
    super(options)
    this.router =
      options.router ??
      new SmartRouter({
        routers: [new RegExpRouter(), new TrieRouter()],
      })
  }
}

export type MiddlewareHandler<
  E extends Env = any,
  P extends string = string,
  I extends Input = {}
> = (c: Context<E, P, I>, next: Next) => Promise<Response | void>
```

另外，router也是个好例子

```jsx
/* eslint-disable @typescript-eslint/ban-ts-comment */
import type { Router, Result } from '../../router'
import { UnsupportedPathError, MESSAGE_MATCHER_IS_ALREADY_BUILT } from '../../router'

export class SmartRouter<T> implements Router<T> {
  name: string = 'SmartRouter'
  routers: Router<T>[] = []
  routes?: [string, string, T][] = []

  constructor(init: Pick<SmartRouter<T>, 'routers'>) {
    Object.assign(this, init)
  }

  add(method: string, path: string, handler: T) {
    if (!this.routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT)
    }

    this.routes.push([method, path, handler])
  }

  match(method: string, path: string): Result<T> {
    if (!this.routes) {
      throw new Error('Fatal error')
    }

    const { routers, routes } = this
    const len = routers.length
    let i = 0
    let res
    for (; i < len; i++) {
      const router = routers[i]
      try {
        routes.forEach((args) => {
          router.add(...args)
        })
        res = router.match(method, path)
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue
        }
        throw e
      }

      this.match = router.match.bind(router)
      this.routers = [router]
      this.routes = undefined
      break
    }

    if (i === len) {
      // not found
      throw new Error('Fatal error')
    }

    // e.g. "SmartRouter + RegExpRouter"
    this.name = `SmartRouter + ${this.activeRouter.name}`

    return res as Result<T>
  }

  get activeRouter() {
    if (this.routes || this.routers.length !== 1) {
      throw new Error('No active router has been determined yet.')
    }

    return this.routers[0]
  }
}
```

简单，规矩。

trpc

# 入门

TS入门是比较简单的，后面学习曲线会越来越陡峭，无论类型推导，还是面向对象，都是需要投入非常大经历学习的。

本节主要讲解ts入门必须要掌握的4个点。

- 转译
- 超集
- 类型添加与草粗
- 如何运行

## 转译

编译和转译是2个概念。

- 编译（Compilation）是指将高级语言（如Java、C++等）编写的代码转换为机器语言（二进制代码）的过程。
- 转译（Transpilation）是指将一种编程语言的代码转换为另一种编程语言的代码的过程。

![Untitled](img/Untitled%207.png)

编译和转译的目的都是将源代码转换为目标代码，但它们的输出结果和使用场景有所不同。编译通常用于将高级语言转换为机器码，以便在特定的硬件平台上直接运行。转译则更多地用于将一种编程语言转换为另一种编程语言，以便在不同的环境或浏览器中运行。

js世界历来有转译的传统，被吐槽最多的就是Brendan Eich用了10天写出来的玩具语言，你可以非常轻松的在Chome Devtools里折腾出很多神奇的bug。另外，作为脚本语言，它其实也不是很严格，各种规范也是很混乱，比如jscript，actionscript等曾经就都是让人分不清楚的。

到现代Web开发，从coffeescript（类Ruby）到Cappuccino（类Objective-c）到rescript（类OCaml语法），到typescript都是转译的思路。最神奇的竟然是es规范发展太快，于是诞生了babeljs这样的现代js转译。除了转译规范，移除类型，啥也不干。

![Untitled](img/Untitled%208.png)

Typescript做的主要的事儿就4件

- 增加类型，这是babel没有的。
- babel超集，可以说babel支持的它基本都支持，包含很多es新特性。
- 部分增强，比如interface，这是babel没有的。
- 转译时擦除类型，比如`type` 和interface一样，在编译时，会被抹除。

## 超集

JavaScript很容易学习，而TypeScript的学习曲线较陡，需要事先有脚本编程知识。
JavaScript是一种脚本语言，而TypeScript是一种面向对象的编程语言。
TypeScript支持模块，而JavaScript不支持。
TypeScript支持静态类型，可以在编译时检查正确的类型，而JavaScript不支持。
TypeScript代码必须编译，但编译JavaScript是不必要的。
TypeScript支持可选参数函数，而JavaScript不支持。
JavaScript有一个庞大的开发者社区，而TypeScript没有。

![Untitled](img/Untitled%209.png)

## 类型添加与擦除

对于一门语言来说，肯定离不开基本数据类型和自定义类型。ts提供了一系列的关键字作为特殊类型代号，其他的都好说，唯一让我有点兴趣的是[`联合类型`](https://www.zhihu.com/search?q=%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3126865898%7D)，这非常有趣的一个特性。

- `typeof` 关键字用于判断是否是某种类型
- `string` 表明是字符串类型，它不同于Java，首字母是小写
- `boolean` 和 `Boolean`类型是不同的
- `number` 直接表示数字类型，没有那么多麻烦的精度问题（0b、0O、0x指明进度问题）
- [`any`](https://www.zhihu.com/search?q=any&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3126865898%7D) 是万能类型，相当于Java中的Object，全部是any相当于是普通js。所以，如果你恨ts，就可以一路any到天明
- `never` 表示那些永不存在的值类型
- `object` 表示非原始类型，和Java中的不太一样
- `string | number` 类似这样的是联合类型，这也是非常神奇的一点。这里只允许这两种类型的转换，并且能调用的方法，要取两者交集
- `` 之间的字符串可以使用类似shell的语法，做模版 `${}`
- `readonly` 这竟然是个关键字，表明只读属性
- `[propName: string]: any;` 这一行代码值得研究，但不推荐这么做
- `number[]` 数组和Java类似，不过这是声明后置的语法，值使用[]声明，而不是{}
- `function` 函数和javascript的没什么区别，有两种声明方式。[lambda](https://www.zhihu.com/search?q=lambda&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3126865898%7D)对js来说肯定是强项
- `=>`的语法也比较恶心人，和ES6联合起来可以写一大篇文章
- `...rest` 注意这个东西！类似Java中[变参](https://www.zhihu.com/search?q=%E5%8F%98%E5%8F%82&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3126865898%7D)的意思
- `as` 是一个关键字，我们可以理解为Java的`cast`，但它也仅仅是语法检查而已，运行时并无法控制。`(window as any)`很酷，但容易出错

由于js是一门弱类型的语言，有很多的运行时转换，就不能使用类似于Java一样的强[类型转换](https://www.zhihu.com/search?q=%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3126865898%7D)方式，所以[`typescript`](https://www.zhihu.com/search?q=typescript&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3126865898%7D)可以在编译阶段通过语言特性增强一些类型检查的功能。而在运行时，大多数根本就没有这样的判断，所以ts更像是一个过程工具。

![Untitled](img/Untitled%2010.png)

那么反过来想想呢？

## 如何运行

1、内置runtime

```tsx
<script src="https://unpkg.com/typescript@4.9/lib/typescriptServices.js"></script>
<script>
const tsCode = 'let num: number = 123;';
const jsCode = window.ts.transpile(tsCode);
document.write(jsCode);
</script>
```

另外一个做法

有了这个环境分离基础，那么就可以实现在浏览器端运行 ts compiler！因为 ts compiler 本身编译后也是 js，只需要提供一个浏览器端的 compilerHost 就可以，typescript 官方提供了一个虚拟文件服务包@typescript/vfs 提供浏览器端兼容的 fs 服务

```tsx
import ts from 'typescript'
import tsvfs from '@typescript/vfs' // 虚拟文件服务
import lzstring from 'lz-string' // 一个压缩算法

// 从cdn创建上下文，包含了ts lib的类型库，从cdn拉取
const fsMap = await tsvfs.createDefaultMapFromCDN(
  compilerOptions,
  ts.version,
  true,
  ts,
  lzstring
)
// 可以设置一个虚拟的文件，文件名index.ts，文件内容第二个参数
fsMap.set('index.ts', '/** typescript 代码 **/')

const system = tsvfs.createSystem(fsMap)
// host是ts编译器将文件操作隔离出来的部分
// 这里可以创建一个虚拟的文件服务，不依赖nodejs，在浏览器中可用
const host = tsvfs.createVirtualCompilerHost(system, compilerOptions, ts)

// 创建编译程序
const program = ts.createProgram({
  rootNames: [...fsMap.keys()],
  options: compilerOptions,
  host: host.compilerHost,
})
```

官方的Playground其实就是这种原理。

2、转译成js后执行

通过编译器编译

```tsx
$ npm install -g typescript
$ tsc hello.ts
```

通过代码

```tsx
const { outputText } = ts.transpileModule(your_ts_code, {
    compilerOptions: {
        strict: false,
        sourceMap: false,
        // 其他编译选项
    }
});
```

# TS学习要点

![Untitled](img/Untitled%2011.png)

最怕学偏了

![Untitled](img/Untitled%2012.png)

1. 用好类型，不要魔化
2. 用好OO，这才是TS的另一个优势
3. Hack的东西少用，可维护性更重要

## 类型基础

以下是一些TypeScript独有的语法和特性：

1. 类型注解：TypeScript可以为变量、函数参数、函数返回值等添加类型注解，以指定它们的数据类型。例如：

```tsx
let age: number = 25;
function add(a: number, b: number): number {
  return a + b;
}

```

1. 接口：TypeScript支持接口的定义，用于描述对象的结构和行为。接口可以定义属性、方法、可选属性、只读属性等。例如：

```tsx
interface Person {
  name: string;
  age: number;
  sayHello(): void;
}

```

1. 泛型：TypeScript支持泛型，用于创建可重用的、类型安全的代码。泛型可以在函数、类、接口中使用，以实现对不同类型的支持。例如：

```tsx
function identity<T>(arg: T): T {
  return arg;
}
let result = identity<number>(10);

```

1. 类型别名和联合类型：TypeScript支持类型别名，用于给一个类型起一个新的名字。它还支持联合类型，用于指定一个变量可以是多个类型中的一个。例如：

```tsx
type Point = {
  x: number;
  y: number;
};
type Shape = Circle | Rectangle | Triangle;

```

1. 枚举：TypeScript支持枚举类型，用于定义一组具名的常量。枚举类型可以是数字枚举或字符串枚举。例如：

```tsx
enum Color {
  Red,
  Green,
  Blue
}
let color: Color = Color.Red;

```

这些是TypeScript独有的一些语法和特性，它们使得TypeScript相比于JavaScript具有更强大的类型检查和面向对象编程的能力。通过使用这些特性，开发者可以更好地组织和管理代码，提高代码的可维护性和可读性。

为了让大家能更好地理解并掌握 TypeScript 内置类型别名，我们先来介绍一下相关的一些基础知识。

1、**typeof**

在 TypeScript 中，`typeof` 操作符可以用来获取一个变量声明或对象的类型。

```
interface Person {
  name: string;
  age: number;
}

const sem: Person = { name: 'semlinker', age: 30 };
type Sem= typeof sem;// -> Person

function toArray(x: number): Array<number> {
  return [x];
}

type Func = typeof toArray;// -> (x: number) => number[]

```

**2、keyof**

`keyof` 操作符可以用来一个对象中的所有 key 值：

```
interface Person {
    name: string;
    age: number;
}

type K1 = keyof Person;// "name" | "age"
type K2 = keyof Person[];// "length" | "toString" | "pop" | "push" | "concat" | "join"
type K3 = keyof { [x: string]: Person };// string | number

```

**3、 in**

`in` 用来遍历枚举类型：

```
type Keys = "a" | "b" | "c"

type Obj =  {
  [p in Keys]: any
}// -> { a: any, b: any, c: any }

```

**4、infer**

在条件类型语句中，可以用 `infer` 声明一个类型变量并且对它进行使用。

```
type ReturnType<T> = T extends (
  ...args: any[]
) => infer R ? R : any;

```

以上代码中 `infer R` 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。

结合下面这种例子，比如容易理解，提取数组的类型。

```tsx
type T0 = string[];
type T1 = number[];

type UnpackedArray<T> = T extends (infer U)[] ? U : T
type U0 = UnpackedArray<T1> // number

let a:U0 = 1
```

变化一下，如果UnpackedArray参数没有类型，此时的a就1或2，这就是T存在的意义的。

```tsx
type T0 = string[];
type T1 = number[];
type T2 = [1,2];

type UnpackedArray<T> = T extends (infer U)[] ? U : T
type U0 = UnpackedArray<T2> // number

let a:U0 = 1
```

提取数组里的第一个元素，也可以这样做。

```tsx
type First<T extends any[]> = T extends [infer A, ...infer test] ? A : never;
```

还有更复杂的例子，简单的Includes

```tsx
type Includes<T extends readonly any[], U> = U extends T[number] ? true : false;
```

![Untitled](img/Untitled%2013.png)

如果数组里，含有对象、数组呢？通过 extends + infer + rest + recursive 可以 loop Tuple 返回一个 Type。

```tsx
type Includes<T extends readonly any[], U> = T extends [infer First, ...infer Rest]
? Equal<U, First> extends true
  ? true
  : Includes<Rest, U>
: false;
```

这样玩下去就很有意思了

5、**extends**

有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。

```
interface ILengthwise {
  length: number;
}

function loggingIdentity<T extends ILengthwise>(arg: T): T {
  console.log(arg.length);
  return arg;
}

```

现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：

```
loggingIdentity(3);// Error, number doesn't have a .length property

```

这时我们需要传入符合约束类型的值，必须包含必须的属性：

```
loggingIdentity({length: 10, value: 3});
```

掌握了这些内容，再看一些[https://github.com/type-challenges/type-challenges/blob/main/utils/index.d.ts](https://github.com/type-challenges/type-challenges/blob/main/utils/index.d.ts)就容易多了

```tsx
export type Expect<T extends true> = T
export type ExpectTrue<T extends true> = T
export type ExpectFalse<T extends false> = T
export type IsTrue<T extends true> = T
export type IsFalse<T extends false> = T

export type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends
  (<T>() => T extends Y ? 1 : 2) ? true : false
export type NotEqual<X, Y> = true extends Equal<X, Y> ? false : true

// https://stackoverflow.com/questions/49927523/disallow-call-with-any/49928360#49928360
export type IsAny<T> = 0 extends (1 & T) ? true : false
export type NotAny<T> = true extends IsAny<T> ? false : true

export type Debug<T> = { [K in keyof T]: T[K] }
export type MergeInsertions<T> =
  T extends object
    ? { [K in keyof T]: MergeInsertions<T[K]> }
    : T

export type Alike<X, Y> = Equal<MergeInsertions<X>, MergeInsertions<Y>>

export type ExpectExtends<VALUE, EXPECTED> = EXPECTED extends VALUE ? true : false
export type ExpectValidArgs<FUNC extends (...args: any[]) => any, ARGS extends any[]> = ARGS extends Parameters<FUNC>
  ? true
  : false

export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never
```

以Equal举例

大佬 [@mattmccutchen](https://link.zhihu.com/?target=https%3A//github.com/mattmccutchen) 给出了一个非常精彩的[解决方案](https://link.zhihu.com/?target=https%3A//github.com/microsoft/TypeScript/issues/27024%23issuecomment-421529650)：

> Here's a solution that makes creative use of the assignability rule for conditional types, which requires that the types after
>
>
> ```
> Here's a solution that makes creative use of the assignability rule for conditional types, which requires that the types after extends be "identical" as that is defined by the checker:
> ts export type Equals<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;
> This passes all the tests from the initial description that I was able to run except H, which fails because the definition of "identical" doesn't allow an intersection type to be identical to an object type with the same properties. (I wasn't able to run test E because I don't have the definition of Head.)
> ```
>

参考：[https://zhuanlan.zhihu.com/p/597298193](https://zhuanlan.zhihu.com/p/597298193)

## 面向对象

TypeScript是JavaScript的超集，它在JavaScript的基础上扩展了一些独有的语法和特性，以提供更强大的类型检查和面向对象编程的支持。

从Java过来的同学，会发现这些概念和Java是类似的，不过ts的语法更加简单。

- `get` `set` 竟然是关键字，后面可直接跟上函数。可以改变属性的赋值和读取行为！
- `static`、`instanceof`、`public`、`protected`、`private`这些也都是有的，真的感觉和写Java没什么两样
- `constructor` 默认是构造方法，不像是Java要和class的名词一样
- `abstract` 也有，表明子类必须实现，没什么两样
- 关于类和接口的区别，我觉得熟悉java的，对ts来说就是透明的
- [范型](https://www.zhihu.com/search?q=%E8%8C%83%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3126865898%7D)在Java里，语法也是非常的变态，因为你很多时候不知道要把`<>`放在什么地方。在ts中，一样的难受。具体怎么熟悉，只有在实践中磨练了

下面是一段简单的ts代码，可以很好的表达面向对象的写法。

```tsx
class Animal {
    public name;
    protected a;
    private b: string;
    constructor(name) {
        this.name = name;
    }
    get name() {
	    return 'Jack';
		}
	  set name(value) {
	    console.log('setter: ' + value);
	  }
    sayhi() {
        return `my name is ${this.name}`;
    }
}

class Cat extends Animal {
    constructor(name) {
        super(name)
    }
    sayhi() {
        return "meow " + super.sayhi()
    }
    static iaAnimal(a) {
        return a instanceof Animal;
    }
}

function gen<T extends Animal>(name: T): void {
    console.log(name.name)
}
```

虽然 JavaScript 中有类的概念，但是可能大多数 JavaScript 程序员并不是非常熟悉类，这里对类相关的概念做一个简单的介绍。

- 类（Class）：定义了一件事物的抽象特点，包含它的属性和方法
- 对象（Object）：类的实例，通过 `new` 生成
- 存取器（getter & setter）：用以改变属性的读取和赋值行为
- 修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 `public` 表示公有属性或方法
- 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现
- 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口

### 面向对象基础

面向对象（OOP）的三大特性：封装、继承、多态

- 封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据
- 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性
- 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 `Cat` 和 `Dog` 都继承自 `Animal`，但是分别实现了自己的 `eat` 方法。此时针对某一个实例，我们无需了解它是 `Cat` 还是 `Dog`，就可以直接调用 `eat` 方法，程序会自动判断出来应该如何执行 `eat`

### 装饰器和IoC

举例Midway或Nestjs，他们都属于同一类的web框架

控制器

```tsx
import { Controller, Get } from '@nestjs/common';
import { CatsService } from './cats.service';
import { Cat } from './interfaces/cat.interface';

@Controller('cats')
export class CatsController {
  constructor(private catsService: CatsService) {}

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll();
  }
}
```

服务层

```tsx
import { Injectable } from '@nestjs/common';
import { Cat } from './interfaces/cat.interface';

@Injectable()
export class CatsService {
  private readonly cats: Cat[] = [];

  create(cat: Cat) {
    this.cats.push(cat);
  }

  findAll(): Cat[] {
    return this.cats;
  }
}
```

实现要点

1. 装饰器获取元数据
2. 通过inversify 或 type地 基于typescript 的ioc 框架，结合元数据实现。

再举个例子，这是java里的测试框架JUnit的写法。

```bash
class MyFirstJUnitJupiterTests {

    private final Calculator calculator = new Calculator();

    @Test
    void addition() {
        assertEquals(2, calculator.add(1, 1));
    }
}
```

放到ts世界，使用类似于midway的写法。

1、使用注解

```bash
class MyFirstJUnitJupiterTests {
  private calculator = new Calculator();

  @Test
  addition() {
    assert.is(2, this.calculator.add(1, 1));
  }
}
```

2、使用ioc容器注入

```bash
class MyFirstJUnitJupiterTests {
  @Inject()
  calculator: Calculator;

  @Test
  addition() {
    assert.is(2, this.calculator.add(1, 1));
  }
}
```

这里的@Test实现如下。

```tsx
export function Test(
  target: object | any,
  propertyName: string,
  descriptor: TypedPropertyDescriptor<any>,
) {
  debug(target[propertyName] + descriptor);

  //classname
  const className = target.constructor.name;

  if (!cache[className]) cache[className] = {};
  if (!cache[className][propertyName]) cache[className][propertyName] = {};

  cache[className][propertyName]["desc"] = "no display name";
  cache[className][propertyName]["fn"] = target[propertyName];
}
```

其实，说白了就是通过装饰器，获取测试用例信息，等执行测试的时候再去调用。

### 设计模式

设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。

![Untitled](img/Untitled%2014.png)

- 5种（创建型模式）：工厂方法模式、抽象工厂模式、单例模式、原型模式、建造者模式。
- 7种（结构型模式）：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
- 11种（行为型模式）：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

本课程作为入门课程，不做深入探讨，以模板模式举例，让大家能够了解什么是设计模式和大致应用即可。

模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern)，在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。

简单说，模板方法模式，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤，这种类型的设计模式属于行为型模式。

用abstract定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现并且必须在派生类中实现

1、抽象方法必须在抽象类中

2、抽象类和抽象方法是一个标准，定义标准后，子类中必须包含抽象定义的方法

```tsx
abstract class Futher { /* 定义一个抽象方法 */
    public age: number;
    constructor(age: number) {
        this.age = age
    }
    abstract counts(): any; /* 抽象方法必须在抽象类中 */
}

class children extends Futher {
    constructor(age: number) {
        super(age)
    }
    counts(): void {    /* 子类中必须有抽象类中的抽象方法 */
        console.log(this.age - 1)
    }
}
```

举例模版模式

```tsx
/**
 * The Abstract Class defines a template method that contains a skeleton of some
 * algorithm, composed of calls to (usually) abstract primitive operations.
 *
 * Concrete subclasses should implement these operations, but leave the template
 * method itself intact.
 */
abstract class AbstractClass {
    /**
     * The template method defines the skeleton of an algorithm.
     */
    public templateMethod(): void {
        this.baseOperation1();
        this.requiredOperations1();
        this.baseOperation2();
        this.hook1();
        this.requiredOperation2();
        this.baseOperation3();
        this.hook2();
    }

    /**
     * These operations already have implementations.
     */
    protected baseOperation1(): void {
        console.log('AbstractClass says: I am doing the bulk of the work');
    }

    protected baseOperation2(): void {
        console.log('AbstractClass says: But I let subclasses override some operations');
    }

    protected baseOperation3(): void {
        console.log('AbstractClass says: But I am doing the bulk of the work anyway');
    }

    /**
     * These operations have to be implemented in subclasses.
     */
    protected abstract requiredOperations1(): void;

    protected abstract requiredOperation2(): void;

    /**
     * These are "hooks." Subclasses may override them, but it's not mandatory
     * since the hooks already have default (but empty) implementation. Hooks
     * provide additional extension points in some crucial places of the
     * algorithm.
     */
    protected hook1(): void { }

    protected hook2(): void { }
}

/**
 * Concrete classes have to implement all abstract operations of the base class.
 * They can also override some operations with a default implementation.
 */
class ConcreteClass1 extends AbstractClass {
    protected requiredOperations1(): void {
        console.log('ConcreteClass1 says: Implemented Operation1');
    }

    protected requiredOperation2(): void {
        console.log('ConcreteClass1 says: Implemented Operation2');
    }
}

/**
 * Usually, concrete classes override only a fraction of base class' operations.
 */
class ConcreteClass2 extends AbstractClass {
    protected requiredOperations1(): void {
        console.log('ConcreteClass2 says: Implemented Operation1');
    }

    protected requiredOperation2(): void {
        console.log('ConcreteClass2 says: Implemented Operation2');
    }

    protected hook1(): void {
        console.log('ConcreteClass2 says: Overridden Hook1');
    }
}

/**
 * The client code calls the template method to execute the algorithm. Client
 * code does not have to know the concrete class of an object it works with, as
 * long as it works with objects through the interface of their base class.
 */
function clientCode(abstractClass: AbstractClass) {
    // ...
    abstractClass.templateMethod();
    // ...
}

console.log('Same client code can work with different subclasses:');
clientCode(new ConcreteClass1());
console.log('');

console.log('Same client code can work with different subclasses:');
clientCode(new ConcreteClass2());
```

还以测试举例，测试框架其实有很多种。如果写法都一样，但底层想使用mocha或jest实现，是不是可以使用模板模式呢？

## 内置类型工具

简单举几个类型工具的例子：

增加字段

```tsx
type X = {
  a: number;
  b: number;
};

type Y = X & {
  c: number;
};

const x: X = { a: 1, b: 2 };
const y: Y = { a: 1, b: 2, c: 3 };
```

合并

```tsx
type X = {
  a: number;
  b: number;
};

type Y = {
  c: number;
};

type Z = X & Y;

const x: X = { a: 1, b: 2 };
const y: Y = { c: 3 };
const z: Z = { a: 1, b: 2, c: 3 };
```

实际上与1等价，因为1中的`{ c: number; }` 等价于就地定义了一个新的类型。

选取

```
type X = {
  a: number;
  b: number;
  c: number;
  d: number;
};

type Y = Pick<X, "b" | "c">;

const y: Y = { b: 1, c: 3 };
```

删除

```tsx
type X = {
  a: number;
  b: number;
  c: number;
};

type Y = Omit<X, "b">;

const y: Y = { a: 1, c: 3 };
```

以上都是十分基础的用法，不涉及到任何复杂的类型体操，但除了1之外没有一个是能轻易在 Java 中实现的，必须通过反射之类的手段。对于更复杂的类型约束，Java 则根本无能为力了。

# 深入学习方法

## 类型学习

首先阅读[文档](https://www.typescriptlang.org/docs/)，里面的内容非常丰富，可读性还是非常不错的。

其次，看https://github.com/gikey/tool-types，虽然它没有star，但更容易理解。

```tsx
/**
 * Intersect
 * @desc 获取两个类型中属性的交集
 * @example
 *   type A = { name: string; age: number };
 *   type B = { name: string; address: string; gender: number; }
 *   // Expect: {name: string}
 *   Intersect<A, B>;
 */
export type Intersect<T, U> = Pick<T, Extract<keyof T, keyof U>>;

/**
 * Except
 * @desc 获取 A - B 差集
 * @example
 *   type A = { name: string; age: number };
 *   type B = { name: string; address: string; gender: number; }
 *   // Expect: { age: number; }
 *   Except<A, B>;
 */
export type Except<T, U> = Pick<T, Exclude<keyof T, keyof U>>;

export type UnionOmit<T, U> = T & Omit<T, keyof U>;

export type TupleUnion<T> = T extends Array<infer U> ? U : never;
```

掌握了这些内容之后，基本类型就过关了。

然后看https://github.com/sindresorhus/type-fest，比如它的basic

```tsx
export type Class<T, Arguments extends unknown[] = any[]> = {
	prototype: T;
	new(...arguments_: Arguments): T;
};

export type Constructor<T, Arguments extends unknown[] = any[]> = new(...arguments_: Arguments) => T;

export interface AbstractClass<T, Arguments extends unknown[] = any[]> extends AbstractConstructor<T, Arguments> {
	prototype: T;
}

export type AbstractConstructor<T, Arguments extends unknown[] = any[]> = abstract new(...arguments_: Arguments) => T;

export type JsonObject = {[Key in string]: JsonValue} & {[Key in string]?: JsonValue | undefined};

export type JsonArray = JsonValue[] | readonly JsonValue[];

export type JsonPrimitive = string | number | boolean | null;

export type JsonValue = JsonPrimitive | JsonObject | JsonArray;
```

再去看其他的就简单多了，比如jsonify。

```tsx
export type Jsonify<T> = IsAny<T> extends true
	? any
	: T extends PositiveInfinity | NegativeInfinity
		? null
		: T extends JsonPrimitive
			? T
			: // Instanced primitives are objects
			T extends Number
				? number
				: T extends String
					? string
					: T extends Boolean
						? boolean
						: T extends Map<any, any> | Set<any>
							? EmptyObject
							: T extends TypedArray
								? Record<string, number>
								: T extends NotJsonable
									? never // Non-JSONable type union was found not empty
									: // Any object with toJSON is special case
									T extends {toJSON(): infer J}
										? (() => J) extends () => JsonValue // Is J assignable to JsonValue?
											? J // Then T is Jsonable and its Jsonable value is J
											: Jsonify<J> // Maybe if we look a level deeper we'll find a JsonValue
										: T extends []
											? []
											: T extends unknown[]
												? JsonifyList<T>
												: T extends readonly unknown[]
													? JsonifyList<WritableDeep<T>>
													: T extends object
														? JsonifyObject<UndefinedToOptional<T>> // JsonifyObject recursive call for its children
														: never; // Otherwise any other non-object is removed
```

## type-challenges

[https://github.com/type-challenges/type-challenges](https://github.com/type-challenges/type-challenges)

安装插件后，不用去 `github` 也可以直接刷题。接着点击下图中的 **Take the Challenge**，第一次，会要求你配置代码存放的路径，配置完成后会自动创建相应的文件，接着可开始刷题啦。*如果不太会可以点击下图中的 **Check out Solutions**，会打开大家分享的相应题目的解答，可以参考参考。*

![Untitled](img/Untitled%2015.png)

![Untitled](img/Untitled%2016.png)

答案

```
type MyPick<T, K extends keyof T> = {
  [key in K]: T[key]
}
```

答案和大部分人都是相同的，只是在这里和说明一下keyof 及 in 的概念及用法，避免刚接触的小伙伴查找。

keyof: 取interface的键后保存为联合类型

```tsx
interface userInfo {
  name: string
  age: number
}
type keyofValue = keyof userInfo
// keyofValue = "name" | "age"
```

in: 取联合类型的值，主要用于数组和对象的构建

切记不要用于interface, 否则会报错

```tsx
type name = 'firstname' | 'lastname'
type TName = {
  [key in name]: string
}
// TName = { firstname: string, lastname: string }
```

用于实际开发，举个例子：

```tsx
function getValue(o:object, key: string){
  return o[key]
}
const obj1 = { name: '张三', age: 18 }
const values = getValue(obj1, 'name')
```

这样写丧失了ts的优势：

1. 无法确定返回值类型
2. 无法对key进行约束

```tsx
function getValue<T extends Object,K extends keyof T>(o: T,key: K): T[K] {
  return o[key]
}
const obj1 = { name: '张三'， age: 18}
const values = getValue(obj1, 'name')
// 如果第二个参数不是obj1中的参数就会报错
```

## chatgpt

```bash
我希望你充当 TypeScript 控制台。我将键入命令，您将回复 TypeScript 类型定义的内容。我希望您只在一个唯一的代码块内回复终端输出，而不是其他任何内容。不要写解释。除非我指示您这样做。
我的第一个命令是你可以通过创建一个新的类型，将on字段中的每个事件处理函数映射到一个新的字段上，该字段的名称是在事件名称前添加on并将其转换为驼峰命名法。
```

结果

```bash
type EventHandlers<T> = {
  [K in keyof T as `on${Capitalize<string & K>}`]: (event: T[K]) => void;
};
```

使用Chrome插件Sider，参见[https://sider.ai/](https://sider.ai/)，原因是chatgpt申请较为麻烦，如果自己想申请chatgpt，可以参考https://github.com/justjavac/chatgpt。

上面的提示词，键入到Sider里，界面如下。

![Untitled](img/Untitled%2017.png)

# 小结

本章简要介绍TypeScript是什么，学习要点，以及如何深入学习。这里我以为和其他课程不一样的是关于学习要点部分。目前前端对ts用法，还是以面向过程为主，面向对象不分讲的相对较少。其次关于类型学习，也算有一些心得，希望能够让大家掌握学习方法，而不是一次性都能教会。

在下一章会针对ts语法和Node.js相关内容进行详细讲解。

其他可参考资源

- [TypeScript 官网](https://link.zhihu.com/?target=https%3A//www.typescriptlang.org/)
- [https://juejin.cn/book/7086408430491172901](https://juejin.cn/book/7086408430491172901) (TypeScript 全面进阶指南)，比较好的入门课程
- [可能是中国最好的 TypeScript 入门到进阶系统教程](https://link.zhihu.com/?target=https%3A//ts.yayujs.com/)
- [TypeScript 使用指南手册](https://link.zhihu.com/?target=http%3A//www.patrickzhong.com/TypeScript/PREFACE.html)
- [深入理解 TypeScript](https://link.zhihu.com/?target=https%3A//jkchao.github.io/typescript-book-chinese/)
- [https://www.typescripttutorial.net/](https://www.typescripttutorial.net/)
- [https://intellisoft.io/typescript-vs-javascript-which-programming-language-fits-your-project/](https://intellisoft.io/typescript-vs-javascript-which-programming-language-fits-your-project/)
- [https://wangdoc.com/typescript/](https://wangdoc.com/typescript/generics#%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%86%99%E6%B3%95)
- [https://typescript.tv/](https://typescript.tv/)
- [https://effectivetypescript.com/](https://effectivetypescript.com/) [下载地址](https://books-library.net/files/books-library.net-10121732Pl7G6.pdf)。