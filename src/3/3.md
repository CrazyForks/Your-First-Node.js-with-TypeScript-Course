# 3、你的第一个TS编写的Node.js项目

前二个章节，我们分别讲解了Node.js v20开发和TypeScript入门，相信大家对Node.js和TS有了大概的了解。本章节讲结合前二章内容，讲解一下如何使用ts开发Node.js应用。虽然内容不复杂，但涉及到ts实际使用中的最佳实践，还是希望大家能够认真学习。

本章主要讲解3T用法，其它仅做了解即可。

- tsx：执行，调试
- tsup：转译成esm或Commonjs，用于发布npm包
- tsdoc: 用于编写文档

# 项目实战

## 工程概览

![Untitled](img/Untitled.png)

## 初始化代码

下面我们看一下，具体实例代码，先通过npm init初始化一下模块配置。

```bash
$ npm init -y
Wrote to /Users/node/workspace/npmstudy/use-typescript-to-write-nodejs/chapter-1/node-with-ts/package.json:

{
  "name": "with-ts",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
```

然后，安装通过npm install —save-dev tsx模块，这个模块12m大小左右，安装还是比较快速的。

```bash
$ npm install —save-dev tsx
// 简写法 npm i -D tsx

added 12 packages, and audited 13 packages in 17s

2 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
```

此时，我们可以将上面node 20里的.mjs代码拿过来，放到.ts里。

```bash
// helloworld.ts
export class HelloWorld {
  say(name) {
    console.log(`Hello ${name}!`)
  }
}
```

## 添加类型声明

此时在VSCode编辑器中会发现，运行会报错误。

![Untitled](img/Untitled%201.png)

这是因为没有安装对应的类型声明模块。

```bash
$ npm i -D @types/node
```

此时就没问题了。在package.json里配置。

```bash
  "scripts": {
    "test": "tsx --test"
  }
```

此时，执行npm test，结果如下。

```bash
$ npm test
ℹ tests 0
ℹ suites 0
ℹ pass 0
ℹ fail 0
ℹ cancelled 0
ℹ skipped 0
ℹ todo 0
ℹ duration_ms 2.13225

```

其实，如果大家理解Node.js 二进制模块安装原理，也可以这样`./node_modules/.bin/tsx --test`执行。上面安装tsx是采用本地安装方式，所以bin命令会被写入到./node_modules/.bin下。在npm script里，可以直接找到对应环境路径，而在Shell中，需要使用具体地址来执行。另外一种，更简单的用法就是npx，它的名字就是npm execute的意思，是简化./node_modules/.bin下cli执行的快捷方式。即，以下三种方式是等同的。

- ./node_modules/.bin/tsx --test
- npx tsx
- 配置npm scripts，在scripts里直接使用tsx

## 类型定义

代码写到这里，发现竟然还没有类型。于是创建index.d.ts文件

```bash
export interface IPerson {
    say(name: string): void;
}
```

改造src/helloworld.ts

```bash
import { IPerson } from "..";

export class HelloWorld implements IPerson {
  say(name: string): void {
    console.log(`Hello, ${name}!`);
  }
}
```

改造点如下。

1. class有类型，通过implements来实现。
2. say方法的参数，约束为string类型，如果开发者调用say方法，不传参或传入其他类型是会报错的。
3. say方法的返回值是void，即无需返回任何内容。如果开发者调用设置返回值，也会被提醒类型错误。

# Tsx编译

前面的项目里使用了tsx作为ts执行工具。相信大家能够看出ts的好处，以及tsx的简便。

![Untitled](img/Untitled%202.png)

tsx vs ts-node

## Tsc

tsc是TypeScript的官方编译器，它可以将TypeScript源代码编译为JavaScript代码。

使用场景：

- 在Node.js项目中使用TypeScript开发时，需要使用tsc将TypeScript代码编译为JavaScript,才能运行。
- 在前端项目中使用TypeScript开发时，也需要编译为JavaScript代码才能让浏览器执行。
- 通过编译可以检查类型错误，保证输出的JavaScript代码质量。

示例：

```tsx

// hello.ts
function greet(name: string) {
  return "Hello " + name;
}

const message = greet("John");

```

使用tsc编译：

```bash

tsc hello.ts

```

这会生成一个hello.js文件：

```

function greet(name) {
  return "Hello " + name;
}

const message = greet("John");

```

编译过程：

1. tsc会解析TypeScript源码，检查语法错误。
2. 对类型进行静态分析，比如检查变量、参数类型是否匹配。
3. 生成相应的JavaScript代码，删除类型注解，编译TypeScript独有的语法。
4. 输出JavaScript代码，可以直接被Node.js或浏览器执行。

tsc是TypeScript项目开发不可缺少的工具，它将TypeScript编译输出为质量更高的JavaScript代码、但它也不是完美的，比如编译速度就是它的硬伤，这也是当前TypeScript生态系统中的一个突出痛点，因此才会出现esbuild、swc、sucrase等同类型的编译器。

## ts-node

ts-node 是一个 Node.js 的执行环境，它可以让你在 Node.js 环境中直接运行 TypeScript 代码。

它通过在运行时将 TypeScript 转译为 JavaScript 来实现这一点，因此你不需要在编写 TypeScript 代码之前先将其转译为 JavaScript。这使得你可以在不离开 Node.js 环境的情况下使用 TypeScript 的语言特性。

ts-node 可以通过 npm 包管理器安装，在命令行中使用以下命令即可安装：

```

$ npm install -g ts-node

```

在安装完成后，你就可以在命令行中使用 `ts-node` 命令来运行 TypeScript 代码了。例如，你可以在命令行中输入以下命令来运行 TypeScript 文件：

```

$ ts-node myFile.ts

```

虽然ts-node在开发过程中提供了很多便利，但也存在一些缺点：

1. 性能：相对于原生的Node.js，ts-node的性能会稍差一些。因为ts-node需要在运行时将TypeScript代码转换为JavaScript代码，这个过程会增加一定的运行时间和内存消耗。在大型项目或需要高性能的场景下，可能会对应用程序的性能产生一定的影响。
2. 内存占用：由于ts-node需要将TypeScript代码编译为JavaScript代码，需要在内存中维护TypeScript编译器的实例。这会增加应用程序的内存占用量，尤其是在处理大型项目或使用大量TypeScript文件时。
3. 调试支持：与原生的Node.js相比，ts-node在调试支持方面可能存在一些限制。例如，某些调试工具可能无法直接与ts-node集成，或者在调试过程中可能无法准确地显示TypeScript源代码的断点位置。
4. 版本兼容性：由于ts-node是一个独立的工具，它需要与Node.js和TypeScript的版本保持兼容。如果你升级了Node.js或TypeScript的版本，可能需要等待ts-node的更新以确保与新版本的兼容性。

尽管ts-node存在一些缺点，但它仍然是一个非常有用的工具，可以加速TypeScript开发过程并提供更好的开发体验。你可以根据自己的项目需求和性能要求来决定是否使用ts-node。

## 编译器

具体来说，tsc作为TypeScript的官方编译器，它的编译速度相比许多其他编译器确实较慢，主要体现在：

1. 冷启动时间长：tsc进程从启动到准备就绪，冷启动时间可达几百毫秒至一秒，对于频繁编译的场景影响较大。
2. 增量编译速度慢：即使启用了增量编译模式，tsc对于代码的小修改，其重新编译生成的速度仍不够理想，较难满足快速迭代的需求。
3. 大项目编译时间长：对于代码量达到几十万行的大型项目，tsc完整编译可需要10秒乃至数分钟，影响开发效率。
4. 并发编译能力有限：tsc单进程编译，难以利用多核CPU优势来加速编译。

正因如此，才会出现一些第三方编译器作为tsc的替代选择，主要有：

- Esbuild: Go语言编写，编译速度可达tsc的几十至上百倍，是目前编译TypeScript最快的编译器。
    - 不关注编译期的类型校验，加上go本身的优势，快
    - 典型的tsx、tsup、vite都是基于esbuild的
    - 它的用法非常简单，本地cli用是极好的
    - 它的语言是go，所以是基于N-Api做的，不要在浏览器里用
- Sucrase: js编写，编译速度较tsc提升15-20倍，但仅编译为ES5代码，功能较为特定。
    - 新版也支持ES6和sourcemap的
    - 纯js，非常快，适合浏览器环境
    - 结合esm.sh，做bundless是极好的选择，比如devjar就是这样做的。
    - 缺点不支持装饰器，所以如果想去做一些midway框架编译就别想了
- SWC:Rust语言编写，增量编译性能优异，编译速度可达tsc的10倍左右。
    - 主要是turbo和rspack在用

可以说，tsc编译性能的局限性，直接催生了更快的编译器作为其补充。下面看一下esbuild给出的性能测试数据，确实是非常快。

![Untitled](img/Untitled%203.png)

<aside>
💡 当开发者开始关注构建速度，就意味主方向已经趋于成熟，这就是当前前端的现状。

</aside>

下面看一下sucrase给出的性能测试数据。

```bash
Time            Speed
Sucrase     0.57 seconds    636975 lines per second
swc         1.19 seconds    304526 lines per second
esbuild     1.45 seconds    248692 lines per second
TypeScript  8.98 seconds    40240 lines per second
Babel       9.18 seconds    39366 lines per second
```

这些编译器解决了tsc在编译时间和增量编译等方面的痛点，为TypeScript的开发和构建带来了更灵活高效的选择。我们能做的就是按照不同的场景选择合适的编译器。

## Sucrase

Sucrase是一个用于加速JavaScript/TypeScript编译的工具。它可以将新版JavaScript或TypeScript代码转换为旧版JavaScript代码，以提高代码的执行性能。

Sucrase的主要特点包括：

1. 快速编译：Sucrase使用了一些优化策略，如基于AST的转换和增量编译，以加快编译速度。相比于传统的Babel编译工具，Sucrase通常可以更快地将代码转换为目标语言。
2. 仅转换语法：与Babel不同，Sucrase专注于转换语法，而不处理运行时特性。这意味着Sucrase不会引入额外的运行时依赖，生成的代码更加轻量且易于理解。
3. 支持最新语法：Sucrase支持最新版本的JavaScript和TypeScript语法，包括类、箭头函数、模板字符串、解构赋值等。这使得开发者可以在不同的环境中使用最新的语言特性，而无需等待所有浏览器或Node.js版本都支持。
4. 可定制性：Sucrase提供了一些选项，可以根据项目需求进行定制。例如，你可以选择是否启用TypeScript支持，是否转换Flow类型注释等。

总体而言，Sucrase是一个轻量且高效的工具，可以在开发过程中加快代码的编译速度，提高应用程序的性能。它在一些性能敏感的项目中特别有用，例如大型应用程序或需要频繁编译的代码库。

它最棒的是它可以运行在浏览器里。在第二章《Hello TypeScript》里，我们有讲过如何在浏览器运行ts，其实原理都是一样的，先下载，转译，然后执行。

下面是https://github.com/huozhi/devjar，核心就是基于Sucrase来实现的。

![Untitled](img/Untitled%204.png)

```tsx
import { DevJar } from 'devjar'

const CDN_HOST = 'https://esm.sh'

const files = {
  'index.js': `export default function App() { return 'hello world' }`
}

function App() {
  return (
    <DevJar
      files={files}
      getModuleUrl={(m) => {
        return `${CDN_HOST}/${m}`
      }}
    />
  )
}
```

原理

1. 通过es-module-lexer获得imports
2. 将imports通过cdn进行加载
3. 插入到script中
4. 执行代码

是不是很巧妙的做法？在开发阶段，这样用是没有任何问题的。在线上，如果对浏览器要求不是那么高，也是OK的，参考[https://caniuse.com/?search=esm](https://caniuse.com/?search=esm)。

![Untitled](img/Untitled%205.png)

Chrome 61起步，大部分ToB产品其实是够用的。

<aside>
💡 有了这些功能，我们还需要Vite吗？其实浏览器足够了。

</aside>

## Tsx和esbuild的秘密

esbuild 是一个非常快速的 JavaScript 打包器，它支持 TypeScript，因此可以很容易地将 TypeScript 项目编译成 JavaScript 代码。如果您想要编译 TypeScript 和 JSX 语法的项目，可以使用以下命令：

```tsx
$ esbuild app.tsx --bundle --outdir=dist --platform=browser --target=es2015
```

其中，`app.tsx` 是您的 TypeScript 和 JSX 代码的入口文件。`--bundle` 表示将所有文件打包成一个文件，`--outdir=dist` 表示输出到 `dist` 目录中，`--platform=browser` 表示目标平台为浏览器，`--target=es2015` 表示目标环境为 ES2015。

您还可以通过在命令中使用 `--watch` 选项来监视您的代码，并在文件更改时重新编译代码：

```bash
$ esbuild app.tsx --bundle --outdir=dist --platform=browser --target=es2015 --watch
```

这将持续监听您的代码，并在更改时重新编译。在这个模式下，您可以在终端中按 `Ctrl+C` 来停止监视模式。

官网讲了它之所以快速的原因。

- esbuild is fast because it doesn't perform any type checking, you already get type checking from your IDE like VS Code or WebStorm. Additionally, if you want type checking at build time, you can enable `--dts`, which will run a real TypeScript compiler to generate declaration file so you get type checking as well.



按照ESBuild官方的测试数据[https://esbuild.github.io/faq/#why-is-esbuild-fast](https://esbuild.github.io/faq/#why-is-esbuild-fast)，它的打包速度目前是最快的。

| Bundler | Time | Relative slowdown | Absolute speed | Output size |
| --- | --- | --- | --- | --- |
| esbuild | 0.37s | 1x | 1479.6 kloc/s | 5.80mb |
| parcel 2 | 30.50s | 80x | 17.9 kloc/s | 5.87mb |
| rollup + terser | 32.07s | 84x | 17.1 kloc/s | 5.81mb |
| webpack 5 | 39.70s | 104x | 13.8 kloc/s | 5.84mb |

之所以快，是因为它不会进行任何类型检查，你已经在你的IDE里（VS Code或WebStorm）里使用了类型检查。如果你真的想要做类型检查

Tsx是目前性能和集成性上都非常好的ts转移模块，之所以说它性能好，是因为它基于esbuild进行构建，编译速度非常快。说它集成性好是因为，它只在Node选项上增加了3个：noCache、tsconfigPath和ipc，其他都和node命令完全一样。

tsx其实就是一个TypeScript loader，cli用法等同于下面任意一种方式。

```bash
# As a CLI flag
node --loader tsx ./file.ts

# As an environment variable
NODE_OPTIONS='--loader tsx' node ./file.ts
```

esbuild用法

```jsx
import esbuild from "esbuild";
import { readFile } from "node:fs/promises";

async function main() {
  const data = await readFile("./fixture.ts");
	await esbuild
    .transform(data, {
      loader: "ts",
    })
    .then((res) => {
      console.log(res.code);
    });
}

main();
```

下面是最简单的esbuild插件

```jsx
import * as esbuild from 'esbuild'
import path from 'node:path'

let exampleOnResolvePlugin = {
  name: 'example',
  setup(build) {
    // Redirect all paths starting with "images/" to "./public/images/"
    build.onResolve({ filter: /^images\// }, args => {
      return { path: path.join(args.resolveDir, 'public', args.path) }
    })

    // Mark all paths starting with "http://" or "https://" as external
    build.onResolve({ filter: /^https?:\/\// }, args => {
      return { path: args.path, external: true }
    })
  },
}

await esbuild.build({
  entryPoints: ['app.js'],
  bundle: true,
  outfile: 'out.js',
  plugins: [exampleOnResolvePlugin],
  loader: { '.png': 'binary' },
})
```

![Untitled](img/Untitled%206.png)

核心原理

![Untitled](img/Untitled%207.png)

<aside>
💡 如果你掌握了ESBuild用法，再看tsx、tsup等，其实就是易用性上的封装，比如各种规范转换，加各种polyfill。难度不大，但确实一个细致的活。

</aside>

# TSDoc文档

`TypeDoc` 是一款 `TypeScript` 文档生成工具，它能够读取你的 `TypeScript` 源文件，对其进行语法分析，根据其中的类型标注与注释内容，自动为你的代码生成包含文档内容的静态网站。甚至可以通过API Extractor生成SDK文档。

选择 `TypeDoc` 主要有以下理由：

- 充分利用了 `TypeScript` 的编译能力，文档内容并不是完全依赖注释，`TypeScirpt` 的原生类型标注也将成文文档的重要内容。
- 注释符合官方的 [tsdoc](https://link.zhihu.com/?target=https%3A//tsdoc.org/) 标准规范。
- 可拓展性强，有许多插件可以满足可能产生的个性化需求。[typedoc 插件](https://link.zhihu.com/?target=https%3A//typedoc.org/guides/plugins/)

TSDoc 的三个组成部分，如下：

- 采用 **TSDoc 规范**编写代码注释
- **api-extractor** 分析代码注释生成文档模型
- **api-documenter** 解析文档模型生成接口文档

> TSDoc 主要包含上面三大步：TSDoc 规范、api-extractor、api-documenter，文档模型也叫做 Doc Model，一般是一个 json 文件：包含了源码中 TSDoc 规范的相关定义
>

api-extractor 是一个单独的 npm 包，需要单独安装：

```
$ npm i -D @microsoft/api-extractor
```

使用之前需要初始化生成配置文件 `api-extractor.json`

```
$ npx api-extractor init
```

然后使用即可，具体用法可查看[官方文档](https://api-extractor.com/pages/setup/invoking/)

```
$ api-extractor run
```

api-documenter 是一个单独的 npm 包，需要单独安装：

```
$ npm i -D @microsoft/api-documenter
```

转换 `*.api.json` 文档模型文件为 markdown 文件：

```
$  npx api-documenter markdown
```

[https://tsdoc.org/play/](https://tsdoc.org/play/)

```json
"scripts": {
    "doc": "npx api-extractor run --local && api-documenter markdown -i temp -o docs/api && node docs/build.js"
  },

```

步骤

1. 抽取 npx api-extractor run --local
2. 变成markdown文档 npx api-documenter markdown -i temp -o docs/api
3. 编译成html并启动http服务端。 node docs/build.js

## 文档编写

选用的是metalsmith，一个基于 NodeJS 开发的超级简单、插件化的静态网站生成工具。之没有选harp、hexo、docsify，vitepress，docusaurus这些大大有名的，但是它们都太重了，安装包比较大，内置功能较多。

metalsmith却恰恰相反，比如jsdoc就是用它编写的，参考[https://github.com/jsdoc/jsdoc.github.io/blob/master/gulpfile.js](https://github.com/jsdoc/jsdoc.github.io/blob/master/gulpfile.js)。

## 示例

下面是官方的[例子](https://github.com/metalsmith/metalsmith/tree/master/examples/static-site)，代码如下

```jsx
import { fileURLToPath } from 'node:url'
import { dirname } from 'node:path'
import Metalsmith from 'metalsmith'
import collections from '@metalsmith/collections'
import layouts from '@metalsmith/layouts'
import markdown from '@metalsmith/markdown'
import permalinks from '@metalsmith/permalinks'

const __dirname = dirname(fileURLToPath(import.meta.url))
const t1 = performance.now()

Metalsmith(__dirname)         // parent directory of this file
  .source('./src')            // source directory
  .destination('./build')     // destination directory
  .clean(true)                // clean destination before
  .env({                      // pass NODE_ENV & other environment variables
    DEBUG: process.env.DEBUG,
    NODE_ENV: process.env.NODE_ENV
  })
  .metadata({                 // add any variable you want & use them in layout-files
    sitename: "My Static Site & Blog",
    siteurl: "https://example.com/",
    description: "It's about saying »Hello« to the world.",
    generatorname: "Metalsmith",
    generatorurl: "https://metalsmith.io/"
  })
  .use(collections({          // group all blog posts by internally
    posts: 'posts/*.md'       // adding key 'collections':'posts'
  }))                         // use `collections.posts` in layouts
  .use(markdown())            // transpile all md into html
  .use(permalinks({           // change URLs to permalink URLs
    relative: false           // put css only in /css
  }))
  .use(layouts())             // wrap layouts around html
  .build((err) => {           // build process
    if (err) throw err        // error handling is required
    console.log(`Build success in ${((performance.now() - t1) / 1000).toFixed(1)}s`)
  });
```

说明如下。

1. source和destination，和gulp用法类似
2. use插件做法，和koa中间用法类似

## 使用已有插件

```jsx

import layouts from "@metalsmith/layouts";

...
.use(
    layouts({
      default: "layout.hbs",
      directory: "./docs/layouts",
      engineOptions: {
        helpers: {
          formattedDate: function (date) {
            return new Date(date).toLocaleDateString();
          },
        },
      },
    })
  )
```

布局文件layout.hbs里需要留好contents插槽。

```jsx
<!DOCTYPE html>
<html>

<head></head>

<body>
  {{{ contents }}}
</body>

</html>
```

其他就是前端熟悉的内容了。

<aside>
💡 此时用handlebars模版，需要安装"jstransformer-handlebars": "^1.2.0"依赖

</aside>

## 扩展插件

扩展插件是一个非常使用的功能，比如我想把文件中的.md替换.html，代码如下。

```jsx
.use(function snapshot(files, metalsmith) {
    // console.log(metalsmith);
    // console.log(files);
    for (const [key, value] of Object.entries(files)) {
      console.log(`   - ${key}`);
      files[key]["contents"] = Buffer.from(
        files[key]["contents"].toString().replaceAll(".md", ".html"),
        "utf-8"
      );
    }
  })
```

## 启动

在构建函数里，启动http服务即可。

```jsx
.build((err) => {
    // build process
    if (err) throw err; // error handling is required
    console.log(
      `Build success in ${((performance.now() - t1) / 1000).toFixed(1)}s`
    );

    // Serve up public/ftp folder
    var serve = serveStatic("dist/docs", {
      index: ["index.html", "index.htm"],
    });

    // Create server
    var server = http.createServer(function onRequest(req, res) {
      serve(req, res, finalhandler(req, res));
    });

    // Listen
    server.listen(3001);

    console.log("creat server success. http://127.0.0.1:3001");
  });
```

以上为Nodejs最简单的http static服务代码。

在做这个地方技术选型的时候，有考虑过serve和http-server、node-static，它们都还是包比较大，使用起来也略微麻烦。结合本课程以入门为主，所以采用node内置的http服务。

执行

```jsx
$ node docs/build.js
   - .DS_Store
   - about.md
   - api/index.md
   - api/your-first-nodejs-helloworld-with-ts.iperson.md
   - api/your-first-nodejs-helloworld-with-ts.iperson.sayhi.md
   - api/your-first-nodejs-helloworld-with-ts.md
   - build.js
   - css/style.css
   - index.md
   - layouts/default.hbs
   - layouts/layout.hbs
   - layouts/post.hbs
Build success in 0.1s
creat server success. http://127.0.0.1:3001
```

![Untitled](img/Untitled%208.png)

# Tsup发布

对比一下esm方式编写的node和ts编写的node项目2个项目

![Untitled](img/Untitled%209.png)

| 项目 | 使用额外构建工具 | 使用ts编写 | 是否需要打包 | 是否需要配置files | 调试是否麻烦 | 增加类型测试 |
| --- | --- | --- | --- | --- | --- | --- |
| esm方式编写 | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| ts编写 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |

## tsup介绍

[tsup](https://tsup.egoist.dev/) 是一个基于 ESBuild 实现在零配置的情况下快速捆绑 Typescript 模块的项目，支持 Node.js 应用中的任何内容，如：.js、.json、.mjs，及 Typescript 中的 .ts、.tsx，还包括实验性的CSS。但在由于部分功能 esbuild 存在天然的不足，但又是开发者密切关注的功能，tsup 同时也选择融合其他的构建工具共同参与，这些内容会在后续的小节说明。

![Untitled](img/Untitled%2010.png)

前端轮子哥egoist编写的。

## ts转esm

在package.json里

```jsx
  "build": "tsup src",
  "scripts": {
		"tsup": {
	    "format": "esm",
	    "target": "node20",
	    "splitting": false,
	    "minify": false,
	    "clean": true
		}
  },
```

执行

```jsx
$ npm run build

> your-first-nodejs-helloworld-with-ts@1.0.0 build
> tsup src

CLI Building entry: src/helloworld.ts, src/main.ts
CLI tsup v7.2.0
CLI Using tsup config: /Users/bytedance/workspace/npmstudy/your-first-nodejs-helloworld-with-ts/package.json
CLI Target: node20
CLI Cleaning output folder
ESM Build start
ESM dist/helloworld.js 364.00 B
ESM dist/main.js       454.00 B
ESM ⚡️ Build success in 330ms
```

## 定制npm包内容

在package.json里，修改如下。

```jsx
"files": [
    "dist",
    "index.d.ts"
  ]
```

这样在发布的npm包里就包含dist目录和.d.ts类型定义文件了。然后执行npm publish发布即可。参见第一节。

# 小结

本章简要介绍3T用法，tsx、tsup和tsdoc是学习要点，当然你也会了解ts编译器的一些应用内容，了解就好，可以不求深入。对于npm包发布，是需要大家掌握的，这属于基本技能。本章的示例比较简单，但细节较多，建议自己动手练习一下。

在下一章会针对ts开发Node.js项目使用VSCode进行调试，也是非常实用的一章，跟我一起学起来。